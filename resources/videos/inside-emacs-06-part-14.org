#+TITLE: FIXME: Inside Emacs 6 part 14
#+AUTHOR: Tony Aldon
#+DATE: <2021-08-05 Thu>
#+PROPERTY: YOUTUBE_LINK  https://youtu.be/ay7zslbSFqg
#+PROPERTY: CONFIG_REPO   https://github.com/tonyaldon/emacs.d
#+PROPERTY: CONFIG_COMMIT 08912d6e6ef29158d1fa8ebbb98d90214ddc805e
#+PROPERTY: VIDEO_SCR_DIR ../src/inside-emacs-06-part-14/
#+TAGS: FIXME

* Description

* Commands
** built-in
*** global-map

~backward-kill-word~ (~M-DEL~): Kill characters backward until
encountering the beginning of a word.

~kill-ring-save~ (~M-w~): Save the region as if killed, but donâ€™t kill
it.

~universal-argument~ (~C-u~): Begin a numeric argument for the following
command.

*** org-mode-map

~org-ctrl-c-ctrl-c~ (~C-c C-c~): Set tags in headline, or update according

~org-mark-element~ (~M-h~): Put point at beginning of this element, mark
at end.

~org-yank~ (~C-y~): Yank.  If the kill is a subtree, treat it specially.

** external

~avy-goto-line~ (from [[https://github.com/abo-abo/avy][avy]]): Jump to a line start in current buffer.

~avy-goto-char~ (from [[https://github.com/abo-abo/avy][avy]]): Jump to the currently visible char (read in
the minibuffer).

** customized
*** handy-mark-pop-local
~handy-mark-pop-local~: Jump to local mark.

#+BEGIN_SRC emacs-lisp
(defun handy-mark-pop-local ()
  "Jump to local mark."
  (interactive)
  (set-mark-command t))
#+END_SRC

*** ta-avy-goto-end-of-line
~ta-avy-goto-end-of-line~: Jump to the visible end of line.

#+BEGIN_SRC emacs-lisp
(require 'avy)

(defun ta-avy-goto-end-of-line ()
  "Jump to the visible end of line.
Call `avy-goto-char' with \"\n\" as argument."
  (interactive)
  (avy-goto-char ?\n))
#+END_SRC

* Emacs Lisp
** format
~format~: Format a string out of a format-string and arguments.

#+BEGIN_SRC C
DEFUN ("format", Fformat, Sformat, 1, MANY, 0,
       doc: /* Format a string out of a format-string and arguments.
The first argument is a format control string.
The other arguments are substituted into it to make the result, a string.

The format control string may contain %-sequences meaning to substitute
the next available argument, or the argument explicitly specified:

%s means print a string argument.  Actually, prints any object, with `princ'.
%d means print as signed number in decimal.
%o means print a number in octal.
%x means print a number in hex.
%X is like %x, but uses upper case.
%e means print a number in exponential notation.
%f means print a number in decimal-point notation.
%g means print a number in exponential notation if the exponent would be
   less than -4 or greater than or equal to the precision (default: 6);
   otherwise it prints in decimal-point notation.
%c means print a number as a single character.
%S means print any object as an s-expression (using `prin1').

The argument used for %d, %o, %x, %e, %f, %g or %c must be a number.
%o, %x, and %X treat arguments as unsigned if `binary-as-unsigned' is t
  (this is experimental; email 32252@debbugs.gnu.org if you need it).
Use %% to put a single % into the output.

A %-sequence other than %% may contain optional field number, flag,
width, and precision specifiers, as follows:

  %<field><flags><width><precision>character

where field is [0-9]+ followed by a literal dollar "$", flags is
[+ #0-]+, width is [0-9]+, and precision is a literal period "."
followed by [0-9]+.

If a %-sequence is numbered with a field with positive value N, the
Nth argument is substituted instead of the next one.  A format can
contain either numbered or unnumbered %-sequences but not both, except
that %% can be mixed with numbered %-sequences.

The + flag character inserts a + before any nonnegative number, while a
space inserts a space before any nonnegative number; these flags
affect only numeric %-sequences, and the + flag takes precedence.
The - and 0 flags affect the width specifier, as described below.

The # flag means to use an alternate display form for %o, %x, %X, %e,
%f, and %g sequences: for %o, it ensures that the result begins with
\"0\"; for %x and %X, it prefixes nonzero results with \"0x\" or \"0X\";
for %e and %f, it causes a decimal point to be included even if the
precision is zero; for %g, it causes a decimal point to be
included even if the precision is zero, and also forces trailing
zeros after the decimal point to be left in place.

The width specifier supplies a lower limit for the length of the
printed representation.  The padding, if any, normally goes on the
left, but it goes on the right if the - flag is present.  The padding
character is normally a space, but it is 0 if the 0 flag is present.
The 0 flag is ignored if the - flag is present, or the format sequence
is something other than %d, %o, %x, %e, %f, and %g.

For %e and %f sequences, the number after the "." in the precision
specifier says how many decimal places to show; if zero, the decimal
point itself is omitted.  For %g, the precision specifies how many
significant digits to print; zero or omitted are treated as 1.
For %s and %S, the precision specifier truncates the string to the
given width.

Text properties, if any, are copied from the format-string to the
produced text.

usage: (format STRING &rest OBJECTS)  */)
  (ptrdiff_t nargs, Lisp_Object *args)
{
  return styled_format (nargs, args, false);
}
#+END_SRC
** org-sbe
~org-sbe~: Return the results of calling SOURCE-BLOCK with VARIABLES.

#+BEGIN_SRC emacs-lisp
(defmacro org-sbe (source-block &rest variables)
  "Return the results of calling SOURCE-BLOCK with VARIABLES.

Each element of VARIABLES should be a list of two elements: the
first element is the name of the variable and second element is a
string of its value.

So this `org-sbe' construct

 (org-sbe \"source-block\" (n $2) (m 3))

is the equivalent of the following source code block:

,#+begin_src emacs-lisp :var results=source-block(n=val_at_col_2, m=3) :results silent
 results
,#+end_src

NOTE: The quotation marks around the function name,
'source-block', are optional.

NOTE: By default, string variable names are interpreted as
references to source-code blocks, to force interpretation of a
cell's value as a string, prefix the identifier a \"$\" (e.g.,
\"$$2\" instead of \"$2\" or \"$@2$2\" instead of \"@2$2\").

NOTE: It is also possible to pass header arguments to the code
block.  In this case a table cell should hold the string value of
the header argument which can then be passed before all variables
as shown in the example below.

| 1 | 2 | :file nothing.png | nothing.png |
,#+TBLFM: @1$4=\\='(org-sbe test-sbe $3 (x $1) (y $2))"
  (declare (debug (form form)))
  (let* ((header-args (if (stringp (car variables)) (car variables) ""))
         (variables (if (stringp (car variables)) (cdr variables) variables)))
    (let* (quote
           (variables
            (mapcar
             (lambda (var)
               ;; ensure that all cells prefixed with $'s are strings
               (cons (car var)
                     (delq nil (mapcar
                                (lambda (el)
                                  (if (eq '$ el)
                                      (prog1 nil (setq quote t))
                                    (prog1
                                        (cond
                                         (quote (format "\"%s\"" el))
                                         ((stringp el) (org-no-properties el))
                                         (t el))
                                      (setq quote nil))))
                                (cdr var)))))
             variables)))
      (unless (stringp source-block)
        (setq source-block (symbol-name source-block)))
      (let ((result
             (if (and source-block (> (length source-block) 0))
                 (let ((params
                        ;; FIXME: Why `eval'?!?!?
                        (eval `(org-babel-parse-header-arguments
                                (concat
                                 ":var results="
                                 ,source-block
                                 "[" ,header-args "]"
                                 "("
                                 (mapconcat
                                  (lambda (var-spec)
                                    (if (> (length (cdr var-spec)) 1)
                                        (format "%S='%S"
                                                (car var-spec)
                                                (mapcar #'read (cdr var-spec)))
                                      (format "%S=%s"
                                              (car var-spec) (cadr var-spec))))
                                  ',variables ", ")
                                 ")")))))
                   (org-babel-execute-src-block
                    nil (list "emacs-lisp" "results" params)
                    '((:results . "silent"))))
               "")))
        (org-trim (if (stringp result) result (format "%S" result)))))))
#+END_SRC
