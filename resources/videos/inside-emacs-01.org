* [2020-07-30 Thu] iedit-mode, multiple-cursors, iy-go-to-char, replace-string | Inside Emacs #1
:PROPERTIES:
:YOUTUBE_TITLE: iedit-mode, multiple-cursors, iy-go-to-char, replace-string | Inside Emacs #1
:YOUTUBE_LINK: https://youtu.be/F1IXixEhQwk
:YOUTUBE_UPLOAD_DATE: [2020-07-30 Thu]
:CONFIG_REPO:   https://github.com/tonyaldon/emacs.d
:CONFIG_COMMIT: f760601bfc92bac7570f74396dbe1e4910af86af
:VIDEO_SCR_DIR: ../src/inside-emacs-01/
:END:
** Built-in commands
*** without default key binding

- ~replace-string~: Interactively, replace occurrences of a string read
  in the minibuffer by another string read in the minibuffer.

*** global-map

- ~scroll-left~ (~C-x <~): Scroll selected window display ARG columns
  left.
- ~scroll-right~ (~C-x >~): Scroll selected window display ARG columns
  right.
- ~yank-rectangle~ (~C-x r y~): Yank the last killed rectangle with upper
  left corner at point.

** External commands

- ~avy-goto-word-or-subword-1~ (from [[https://github.com/abo-abo/avy][avy]]): Jump to the currently visible
  char (read in the minibuffer) at a subword or word start.
- ~company-complete-selection~ (from [[https://github.com/company-mode/company-mode][company]]): Insert the selected
  candidate.
- ~er/expand-region~ (from [[https://github.com/magnars/expand-region.el][expand-region]]): Increase selected region by
  semantic units.
- ~iedit-mode~ (from [[https://github.com/victorhge/iedit][iedit]]): Toggle Iedit mode.  When Iedit mode is
  turned on, all the occurrences of the current region in the buffer
  (possibly narrowed) or a region are highlighted.  If one occurrence
  is modified, the change are propagated to all other occurrences
  simultaneously.
- ~iy-go-to-char~ (from [[https://github.com/doitian/iy-go-to-char][iy-go-to-char]]):  Move forward to next char read
  in the minibuffer.
- ~iy-go-to-char-kill-region~ (from [[https://github.com/doitian/iy-go-to-char][iy-go-to-char]]): Kill region between
  jump start position and current position.
- ~iy-go-to-char-kill-ring-save~ (from [[https://github.com/doitian/iy-go-to-char][iy-go-to-char]]): Save region
  between jump start position and current position.
- ~mc/insert-numbers~ (from [[https://github.com/magnars/multiple-cursors.el][multiple-cursors]]): Insert increasing numbers
  for each cursor, starting at ~mc/insert-numbers-default~ or universal
  argument.
- ~mc/mark-next-like-this~ (from [[https://github.com/magnars/multiple-cursors.el][multiple-cursors]]): Find and mark the
  next part of the buffer matching the currently active region.
- ~mc/mark-next-like-this-word~ (from [[https://github.com/magnars/multiple-cursors.el][multiple-cursors]]): Find and mark
  the next part of the buffer matching the currently active region.

** Customized commands
*** cleanup-buffer

~cleanup-buffer~: Convert all tabs into spaces, delete trailing spaces
and indent buffer.

#+BEGIN_SRC emacs-lisp
(defun cleanup-buffer ()
  "Convert all tabs into spaces, delete trailing spaces and indent buffer."
  (interactive)
  (untabify (point-min) (point-max))
  (delete-trailing-whitespace)
  (indent-region (point-min) (point-max)))
#+END_SRC

*** ta-avy-goto-end-of-line

~ta-avy-goto-end-of-line~: Jump to the visible end of line.

#+BEGIN_SRC emacs-lisp
(require 'avy)

(defun ta-avy-goto-end-of-line ()
  "Jump to the visible end of line.
Call `avy-goto-char' with \"\n\" as argument."
  (interactive)
  (avy-goto-char ?\n))
#+END_SRC

*** ta-mark-sexp-at-point

~ta-mark-sexp-at-point~: Mark the ~sexp~ at point.

#+BEGIN_SRC emacs-lisp
(require 'smartparens)

(defun ta--point-at-beginnig-sp-sexp-p ()
  "Return non-nil if `point' is at the beginning of a sp-sexp

and :op non empty. See `sp-get-thing'."
  (let ((ok (sp-get-thing)))
    (when ok
      (when (and (eq (point) (sp-get ok :beg))
                 (not (string-empty-p (sp-get ok :op))))
        (point)))))

(defun ta--mark-sexp-at-point ()
  "Mark the `sexp' at point."
  (let ((sexp-beg (beginning-of-thing 'sexp))
        (sexp-end (end-of-thing 'sexp)))
    (goto-char sexp-end)
    (set-mark sexp-end)
    (goto-char sexp-beg)))

(defun ta-mark-sexp-at-point ()
  "Mark the `sexp' at point. See `sexp-at-point' and `sp-mark-sexp'."
  (interactive)
  (if (or (ta--point-at-beginnig-sp-sexp-p)
          (eq (following-char) ?<))
      (sp-mark-sexp)
    (if (eq (preceding-char) ?\")
        (progn
          (sp-backward-sexp)
          (sp-mark-sexp))
      (if (and (memq (following-char) '(32 ?\) ?\] ?\} ?>))
               (looking-back "[[:alnum:]]" 1))
          (backward-char 1))
      (ta--mark-sexp-at-point))))
#+END_SRC

*** ta-toggle-narrow

~ta-toggle-narrow~: Toggle between ~widen~ and ~org-narrow-to-subtree~.

#+BEGIN_SRC emacs-lisp
(defun ta-toggle-narrow ()
  "Toggle between `widen' and `org-narrow-to-subtree'."
  (interactive)
  (if (buffer-narrowed-p) (widen)
    (org-narrow-to-subtree)))
#+END_SRC

~ta-yank-line-below~:  Copy current line and past it below.

#+BEGIN_SRC emacs-lisp
(defun ta-yank-line-below ()
  "Copy current line and past it below."
  (interactive)
  (let ((init-point (point))
        (line (buffer-substring-no-properties (point-at-bol) (point-at-eol))))
    (save-excursion
      (next-line)
      (beginning-of-line)
      (insert (concat line "\n")))))
#+END_SRC
