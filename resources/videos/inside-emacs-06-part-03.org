#+TITLE: FIXME: Inside Emacs 6 part 3
#+AUTHOR: Tony Aldon
#+DATE: <2021-08-05 Thu>
#+PROPERTY: YOUTUBE_LINK  https://youtu.be/KxOwKK5sXRA
#+PROPERTY: CONFIG_REPO   https://github.com/tonyaldon/emacs.d
#+PROPERTY: CONFIG_COMMIT 124a1958e4e222722980ced00724f0ee7c948575
#+PROPERTY: VIDEO_SCR_DIR ../src/inside-emacs-06-part-03/
#+TAGS: FIXME

* Commands
** built-in
*** without default key binding

- ~eval-defun~: Evaluate the top-level form containing point, or after
  point.
- ~join-line~: Join this line to previous and fix up whitespace at
  join.

*** global-map

- ~previous-buffer~ (~C-x <left>~): In selected window switch to previous
  buffer.
- ~repeat~ (~C-x z~): Repeat most recently executed command.
- ~undo~ (~C-x u~): Undo some previous changes.

*** org-mode-map

- ~org-ctrl-c-ctrl-c~ (~C-c C-c~): Set tags in headline, or update
  according to changed information at point.
- ~org-meta-return~ (~<M-return>~): Insert a new heading or wrap a region
  in a table.
- ~org-return~ (~RET~): Goto next table row or insert a newline.

*** org-mode

- ~org-table-wrap-region~: Wrap several fields in a column like a
  paragraph.

** external

- ~avy-goto-char~ (from [[https://github.com/abo-abo/avy][avy]]): Jump to the currently visible char (read
  in the minibuffer).
- ~avy-goto-line~ (from [[https://github.com/abo-abo/avy][avy]]): Jump to a line start in current buffer.
- ~mc/mark-next-like-this~ (from [[https://github.com/magnars/multiple-cursors.el][multiple-cursors]]): Find and mark the
  next part of the buffer matching the currently active region.
- ~yas-expand~ (from [[https://github.com/joaotavora/yasnippet][yasnippet]]): Expand a snippet before point.
- ~sp-backward-up-sexp~ (from [[https://github.com/Fuco1/smartparens][smartparens]]): Move backward out of one
  level of parentheses.
- ~sp-forward-slurp-sexp~ (from [[https://github.com/Fuco1/smartparens][smartparens]]): Add sexp following the
  current list in it by moving the closing delimiter.

** customized
*** my-org-meta-return

~my-org-meta-return~: Insert a new heading or wrap a region in a table.

#+BEGIN_SRC emacs-lisp
(defun my-org-meta-return (&optional arg)
  "Insert a new heading or wrap a region in a table.
Calls `org-insert-heading', `org-insert-item' or
`org-table-wrap-region', depending on context."
  (interactive "P")
  (org-check-before-invisible-edit 'insert)
  (or (run-hook-with-args-until-success 'org-metareturn-hook)
      (if (org-at-table-p)
          (org-table-wrap-region arg)
        (call-interactively
         (cond (arg #'org-insert-heading)
               ((org-in-item-p) #'org-insert-item)
               (t #'org-insert-heading))))))
#+END_SRC

*** ta-avy-copy-sexp

~ta-avy-copy-sexp~: Copy ta point a visible sexp selected with ~avy~.

#+BEGIN_SRC emacs-lisp
(require 'avy)
(require 'smartparens)

(defun ta-avy-copy-sexp ()
  "Copy at point a visible sexp selected with `avy'."
  (interactive)
  (let ((initial-window (selected-window)))
    (save-excursion
      (call-interactively 'avy-goto-word-or-subword-1)
      (sp-copy-sexp))
    (select-window initial-window)
    (yank)))
#+END_SRC

*** ta-avy-goto-end-of-line

~ta-avy-goto-end-of-line~: Jump to the visible end of line.

#+BEGIN_SRC emacs-lisp
(require 'avy)

(defun ta-avy-goto-end-of-line ()
  "Jump to the visible end of line.
Call `avy-goto-char' with \"\n\" as argument."
  (interactive)
  (avy-goto-char ?\n))
#+END_SRC

*** ta-kill-whole-line

~ta-kill-whole-line~: Kill the whole current line.

#+BEGIN_SRC emacs-lisp
(defun ta-kill-whole-line ()
  "Kill the whole current line.
Preserve the column position of the cursor."
  (interactive)
  (let ((column-position (current-column)))
    (kill-whole-line)
    (move-to-column column-position)))
#+END_SRC

*** ta-mark-inside-dwim

~ta-mark-inside-dwim~: Mark things inside quotes if point is inside a
string.

#+BEGIN_SRC emacs-lisp
(require 'expand-region)
(require 'smartparens)

(defun ta-mark-inside-org-table ()
  "Mark current field inside org-table."
  (interactive)
  (when (org-at-table-p)
    (push-mark (point))
    (re-search-forward "|")
    (backward-char)
    (skip-chars-backward " ")
    (push-mark (point))
    (set-mark (point))
    (org-table-beginning-of-field 1)))

(defun ta-mark-inside-pairs ()
  "An other way to do `er/mark-inside-pairs' but work for sgml-tag too."
  (interactive)
  (ta-goto-begining-of-string (point))
  (sp-backward-up-sexp)
  (sp-mark-sexp)
  (sp-down-sexp)
  (exchange-point-and-mark)
  (sp-backward-down-sexp)
  (exchange-point-and-mark))

(defun ta-mark-inside-dwim (&optional arg)
  "Mark things inside quotes if point is inside a string.

If not inside string, mark inside table field in `org-mode'.
In other modes, mark things inside pairs.
If call two times consecutively mark inside pairs."
  (interactive)
  (cond ((equal last-command 'ta-mark-inside-dwim)
         (call-interactively 'ta-mark-inside-pairs))
        ((er--point-inside-string-p)
         (call-interactively 'er/mark-inside-quotes))
        ((and (equal major-mode 'org-mode) (org-at-table-p))
         (ta-mark-inside-org-table))
        (t (call-interactively 'ta-mark-inside-pairs))))

#+END_SRC

*** ta-mark-sexp-at-point

~ta-mark-sexp-at-point~: Mark the sexp at point

#+BEGIN_SRC emacs-lisp
(require 'smartparens)

(defun ta--point-at-beginnig-sp-sexp-p ()
  "Return non-nil if `point' is at the beginning of a sp-sexp

and :op non empty. See `sp-get-thing'."
  (let ((ok (sp-get-thing)))
    (when ok
      (when (and (eq (point) (sp-get ok :beg))
                 (not (string-empty-p (sp-get ok :op))))
        (point)))))

(defun ta--mark-sexp-at-point ()
  "Mark the `sexp' at point."
  (let ((sexp-beg (beginning-of-thing 'sexp))
        (sexp-end (end-of-thing 'sexp)))
    (goto-char sexp-end)
    (set-mark sexp-end)
    (goto-char sexp-beg)))

(defun ta-mark-sexp-at-point ()
  "Mark the `sexp' at point. See `sexp-at-point' and `sp-mark-sexp'
(smartparens packages)."
  (interactive)
  (if (or (ta--point-at-beginnig-sp-sexp-p)
          (eq (following-char) ?<))
      (sp-mark-sexp)
    (if (eq (preceding-char) ?\")
        (progn
          (sp-backward-sexp)
          (sp-mark-sexp))
      (if (and (memq (following-char) '(32 ?\) ?\] ?\} ?>))
               (looking-back "[[:alnum:]]" 1))
          (backward-char 1))
      (ta--mark-sexp-at-point))))
#+END_SRC

*** ta-org-table-previous-row

~ta-org-table-previous-row~: Go to the previous row (same column) in
the current table.

#+BEGIN_SRC emacs-lisp
(defun ta-org-table-previous-row ()
  "Go to the previous row (same column) in the current table.
Before doing so, re-align the table if necessary."
  (interactive)
  (unless (org-at-table-hline-p)
    (org-table-maybe-eval-formula)
    (org-table-maybe-recalculate-line))
  (if (and org-table-automatic-realign
           org-table-may-need-update)
      (org-table-align))
  (let ((col (org-table-current-column)))
    (when (and (org-at-table-p)
               (not (= (org-table-current-line) 1)))
      (previous-line)
      (unless (org-at-table-hline-p)
        (org-table-goto-column col)))))
#+END_SRC

* Emacs Lisp

- ~call-interactively~: Call FUNCTION, providing args according to its
  interactive calling specs.
- ~define-key~: In KEYMAP, define key sequence KEY as DEF.
- ~org-at-table-p~: Non-nil if the cursor is inside an Org table.
- ~org-in-item-p~: Return item beginning position when in a plain list,
  nil otherwise.
- ~org-insert-heading~: Insert a new heading or an item with the same
  depth at point.
- ~org-insert-item~: Insert a new item at the current level.
