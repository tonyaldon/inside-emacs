#+TITLE: FIXME: Inside Emacs 6 part 13
#+AUTHOR: Tony Aldon
#+DATE: <2021-08-05 Thu>
#+PROPERTY: YOUTUBE_LINK  https://youtu.be/w3LbuI5naMI
#+PROPERTY: CONFIG_REPO   https://github.com/tonyaldon/emacs.d
#+PROPERTY: CONFIG_COMMIT 08912d6e6ef29158d1fa8ebbb98d90214ddc805e
#+PROPERTY: VIDEO_SCR_DIR ../src/inside-emacs-06-part-13/
#+TAGS: FIXME

* Description

* Commands
** built-in
*** global-map

- ~isearch-forward~ (~C-s~): Do incremental search forward.
- ~kill-ring-save~ (~M-w~): Save the region as if killed, but donâ€™t kill
  it.

*** org-mode-map

- ~org-set-property~ (~C-c C-x p~): In the current entry, set a property
  read in the minibuffer with a value read in the minibuffer.
- ~org-edit-special~ (~C-c '~): Call a special editor for the element at point.
- ~org-ctrl-c-ctrl-c~ (~C-c C-c~): Set tags in headline, or update according
- ~org-yank~ (~C-y~): Yank.  If the kill is a subtree, treat it specially.
- ~org-cycle~ (~TAB~): TAB-action and visibility cycling for Org mode.
- ~org-mark-element~ (~M-h~): Put point at beginning of this element, mark at end.

*** org-table-fedit-map

- ~org-table-fedit-finish~ (~C-c '~): Parse the buffer for formula
  definitions and install them.

** external

- ~avy-goto-char~ (from [[https://github.com/abo-abo/avy][avy]]): Jump to the currently visible char (read
  in the minibuffer).
- ~avy-goto-line~ (from [[https://github.com/abo-abo/avy][avy]]): Jump to a line start in current buffer.
- ~mc/mark-previous-like-this-word~ (from [[https://github.com/magnars/multiple-cursors.el][multiple-cursors]]): Find and
  mark the previous part of the buffer matching the currently active
  region.

** customized
*** handy-expand-region-dwim

~handy-expand-region-dwim~: If region is active, call
~er/expand-region~.  If not call ~er/mark-word~.

#+BEGIN_SRC emacs-lisp
(require 'expand-region)

(defun handy-expand-region-dwim (arg)
  "If region is active, call `er/expand-region'.  If not call `er/mark-word'."
  (interactive "p")
  (if (or (region-active-p) (equal last-command this-command))
      (er/expand-region arg)
    (er/mark-word)
    (if (equal arg 4) (exchange-point-and-mark))))
#+END_SRC

*** handy-mark-dwim

~handy-mark-dwim~: Mark the url, sexp or sentence at point.

#+BEGIN_SRC emacs-lisp
(require 'smartparens)
(require 'expand-region)

(defun handy-point-in-url-p ()
  "Return the url at `point' if `point' is in an url."
  (thing-at-point 'url))

(defun handy-point-at-beginning-of-sexp-delimited-by-pairs-p ()
  "Return t if point is at beginning of sexp delimited by pairs."
  (let ((sexp (sp-get-thing)))
    (and (eq (point) (sp-get sexp :beg))
         (not (string-empty-p (sp-get sexp :op))))))

(defun handy-mark-sexp-at-point ()
  "Mark the `sexp' at point."
  (let ((sexp-beg (beginning-of-thing 'sexp))
        (sexp-end (end-of-thing 'sexp)))
    (goto-char sexp-end)
    ;; HACK: Have to use both `push-mark' and `set-mark' in this order to
    ;;       expected result.
    (push-mark sexp-end)
    (set-mark sexp-end)
    (goto-char sexp-beg)))

(defun handy-mark-dwim (arg)
  "Mark the url, sexp or sentence at point.

If point is in a url, call `er/mark-url'.  If not mark sexp at point.
If call 2 times consecutively, call `er/mark-sentence'."
  (interactive "p")
  (cond
   ((equal last-command this-command)
    (er/mark-sentence))
   ((handy-point-in-url-p)
    (er/mark-url))
   ((or (handy-point-at-beginning-of-sexp-delimited-by-pairs-p)
        (eq (following-char) ?<))
    (sp-mark-sexp))
   ((eq (preceding-char) ?\")
    (sp-backward-sexp)
    (sp-mark-sexp))
   ((and (memq (following-char) '(32 ?\) ?\] ?\} ?>))
         (looking-back "[[:alnum:]]" 1))
    (backward-char 1)
    (handy-mark-sexp-at-point))
   (t (handy-mark-sexp-at-point)))
  (if (equal arg 4) (exchange-point-and-mark)))
#+END_SRC

*** ta-avy-goto-end-of-line

~ta-avy-goto-end-of-line~: Jump to the visible end of line.

#+BEGIN_SRC emacs-lisp
(require 'avy)

(defun ta-avy-goto-end-of-line ()
  "Jump to the visible end of line.
Call `avy-goto-char' with \"\n\" as argument."
  (interactive)
  (avy-goto-char ?\n))
#+END_SRC

* Emacs Lisp

- ~org-lookup-first~: Find first occurrence of VAL in S-LIST; return
  corresponding element of R-LIST.
- ~org-lookup-last~: Find last occurrence of VAL in S-LIST; return
  corresponding element of R-LIST.
- ~org-lookup-all~: Find all occurrences of VAL in S-LIST; return
  corresponding elements of R-LIST.
