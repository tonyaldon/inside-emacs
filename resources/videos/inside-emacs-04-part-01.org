* [2020-08-23 Sun] company-mode, showcase, source code, faces | Inside Emacs #4 (part 1)
:PROPERTIES:
:YOUTUBE_TITLE: company-mode, showcase, source code, faces | Inside Emacs #4 (part 1)
:YOUTUBE_LINK: https://youtu.be/96jn5A73-oQ
:YOUTUBE_UPLOAD_DATE: [2020-08-23 Sun]
:CONFIG_REPO:   https://github.com/tonyaldon/emacs.d
:CONFIG_COMMIT: 4cbdb3ce735ae296387069ef7ff309f0cfa812e8
:VIDEO_SCR_DIR: ../src/inside-emacs-04-part-01/
:END:
** Built-in commands
*** without default key binding

- ~eval-defun~: Evaluate the top-level form containing point, or after
  point.
- ~join-line~: Join this line to previous and fix up whitespace at
  join.

*** global-map

- ~delete-blank-lines~ (~C-x C-o~): On blank line, delete all surrounding
  blank lines, leaving just one.
- ~open-line~ (~C-o~): Insert a newline and leave point before it.

** External commands

- ~avy-goto-word-or-subword-1~ (from [[https://github.com/abo-abo/avy][avy]]): Jump to the currently visible
  char (read in the minibuffer) at a subword or word start.
- ~bicycle-cycle~ (from [[https://github.com/tarsius/bicycle][bicycle]]): Cycle local or global visibility.
- ~company-complete-selection~ (from [[https://github.com/company-mode/company-mode][company]]): Insert the selected candidate.
- ~company-filter-candidates~ (from [[https://github.com/company-mode/company-mode][company]]): Start filtering the
  completion candidates incrementally.
- ~counsel-outline~ (from [[https://github.com/abo-abo/swiper][counsel]]): Jump to an outline heading with completion.
- ~yas-expand~ (from [[https://github.com/joaotavora/yasnippet][yasnippet]]): Expand a snippet before point.
- ~sp-forward-slurp-sexp~ (from [[https://github.com/Fuco1/smartparens][smartparens]]): Add sexp following the
  current list in it by moving the closing delimiter.

** Customized commands
*** ta-avy-copy-sexp

~ta-avy-copy-sexp~: Copy ta point a visible sexp selected with ~avy~.

#+BEGIN_SRC emacs-lisp
(require 'avy)
(require 'smartparens)

(defun ta-avy-copy-sexp ()
  "Copy at point a visible sexp selected with `avy'."
  (interactive)
  (let ((initial-window (selected-window)))
    (save-excursion
      (call-interactively 'avy-goto-word-or-subword-1)
      (sp-copy-sexp))
    (select-window initial-window)
    (yank)))
#+END_SRC

*** ta-kill-whole-line

~ta-kill-whole-line~: Kill the whole current line.

#+BEGIN_SRC emacs-lisp
(defun ta-kill-whole-line ()
  "Kill the whole current line.
Preserve the column position of the cursor."
  (interactive)
  (let ((column-position (current-column)))
    (kill-whole-line)
    (move-to-column column-position)))
#+END_SRC

*** ta-mark-sexp-at-point

~ta-mark-sexp-at-point~: Mark the ~sexp~ at point.

#+BEGIN_SRC emacs-lisp
(require 'smartparens)

(defun ta--point-at-beginnig-sp-sexp-p ()
  "Return non-nil if `point' is at the beginning of a sp-sexp

and :op non empty. See `sp-get-thing'."
  (let ((ok (sp-get-thing)))
    (when ok
      (when (and (eq (point) (sp-get ok :beg))
                 (not (string-empty-p (sp-get ok :op))))
        (point)))))

(defun ta--mark-sexp-at-point ()
  "Mark the `sexp' at point."
  (let ((sexp-beg (beginning-of-thing 'sexp))
        (sexp-end (end-of-thing 'sexp)))
    (goto-char sexp-end)
    (set-mark sexp-end)
    (goto-char sexp-beg)))

(defun ta-mark-sexp-at-point ()
  "Mark the `sexp' at point. See `sexp-at-point' and `sp-mark-sexp'
(smartparens packages)."
  (interactive)
  (if (or (ta--point-at-beginnig-sp-sexp-p)
          (eq (following-char) ?<))
      (sp-mark-sexp)
    (if (eq (preceding-char) ?\")
        (progn
          (sp-backward-sexp)
          (sp-mark-sexp))
      (if (and (memq (following-char) '(32 ?\) ?\] ?\} ?>))
               (looking-back "[[:alnum:]]" 1))
          (backward-char 1))
      (ta--mark-sexp-at-point))))
#+END_SRC

*** ta-outline-toggle-global

~ta-outline-toggle-global~:  Toggle visibility of all outline
sections.  This is a variant off the ~bicycle-cycle-global~ with two
levels less.

#+BEGIN_SRC emacs-lisp
(require 'bicycle)

(defun ta-outline-toggle-global ()
  "Toggle visibility of all outline (see `outline-mode') sections.

This command toggle between this following levels:
1. TREES:    Show all headings, treaing top-level code blocks
             as sections (i.e. their first line is treated as
             a heading).
2. ALL:      Show everything, except code blocks that have been
             collapsed individually (using a `hideshow' command
             or function).

This is a variant off the `bicycle-cycle-global' with two
levels less."
  (interactive)
  (setq deactivate-mark t)
  (save-excursion
    (goto-char (point-min))
    (unless (re-search-forward outline-regexp nil t)
      (user-error "Found no heading"))
    (cond
     ((eq last-command 'outline-cycle-trees)
      (outline-show-all)
      (bicycle--message "ALL"))
     (t
      (outline-hide-sublevels (bicycle--level))
      (outline-map-region
       (lambda ()
         (when (bicycle--top-level-p)
           (outline-show-branches)))
       (point-min)
       (point-max))
      (bicycle--message "TREES")
      (setq this-command 'outline-cycle-trees)))))
#+END_SRC

*** ta-sidebar

~ta-sidebar~: Pop up a buffer on the left of the frame in ~dired-mode~.

#+BEGIN_SRC emacs-lisp
(require 'dired)
(require 'dired-hacks-utils)
(require 'dash)

(defun ta-dired-width (dir)
  "String length of the longest filename in DIR."
  (with-current-buffer (dired-noselect dir)
    (-max (--map (length (-last-item (s-split "/" it)))
                 (dired-utils-get-all-files)))))

(defun ta-sidebar ()
  "Pop up a buffer on the left of the frame in `dired-mode'.
If the frame contains buffers in `dired-mode', delete them."
  (interactive)
  (let ((initial-window (selected-window))
        dired-window-deleted-p
        buff-file-name)
    (--each (window-list)
      (select-window it)
      (if (string-equal major-mode "dired-mode")
          (progn (delete-window) (setq dired-window-deleted-p t))))
    (unless dired-window-deleted-p
      (select-window initial-window)
      (delete-other-windows)
      (setq buff-file-name
            (file-name-directory (cond (buffer-file-name) ("~/"))))
      (let ((width (ta-dired-width buff-file-name)))
        (split-window-right (+ 10 width))) ; 10 is arbitrary
      (dired buff-file-name))))
#+END_SRC
