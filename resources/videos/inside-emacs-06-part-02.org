#+TITLE: FIXME: Inside Emacs 6 part 2
#+AUTHOR: Tony Aldon
#+DATE: <2021-08-05 Thu>
#+PROPERTY: YOUTUBE_LINK  https://youtu.be/RhwCClMdaps
#+PROPERTY: CONFIG_REPO   https://github.com/tonyaldon/emacs.d
#+PROPERTY: CONFIG_COMMIT 6982f26e031a6aaa82515274d8572204fffaec56
#+PROPERTY: VIDEO_SCR_DIR ../src/inside-emacs-06-part-02/
#+TAGS: FIXME

* Description

* Commands
** built-in
*** without default key binding

~eval-defun~: Evaluate the top-level form containing point, or after
point.

~join-line~: Join this line to previous and fix up whitespace at join.

*** global-map

~eval-expression~ (~M-:~): Read an Emacs Lisp expression in the minibuffer
and evaluate it.

~kill-ring-save~ (~M-w~): Save the region as if killed, but donâ€™t kill it.

~next-buffer~ (~C-x <right>~): In selected window switch to next buffer.

~previous-buffer~ (~C-x <left>~): In selected window switch to previous buffer.

*** org-mode-map

~org-backward-sentence~ (~M-a~): Go to beginning of sentence, or beginning
of table field.

~org-forward-sentence~ (~M-e~): Go to end of sentence, or end of table
field.

~org-cycle~ (~TAB~): TAB-action and visibility cycling for Org mode.

~org-return~ (~RET~): Goto next table row or insert a newline.

~org-shifttab~ (~S-TAB~): Global visibility cycling or move to previous
table field.

** external

~avy-goto-char~ (from [[https://github.com/abo-abo/avy][avy]]): Jump to the currently visible char (read in
the minibuffer).

~avy-goto-line~ (from [[https://github.com/abo-abo/avy][avy]]): Jump to a line start in current buffer.

~er/expand-region~ (from [[https://github.com/magnars/expand-region.el][expand-region]]): Increase selected region by
semantic units.

~iy-go-to-char~ (from [[https://github.com/doitian/iy-go-to-char][iy-go-to-char]]):  Move forward to next char read in
the minibuffer.

~mc/mark-next-like-this-word~ (from [[https://github.com/magnars/multiple-cursors.el][multiple-cursors]]): Find and mark the
next part of the buffer matching the currently active region.


~sp-backward-sexp~ (from [[https://github.com/Fuco1/smartparens][smartparens]]):

~sp-backward-up-sexp~ (from [[https://github.com/Fuco1/smartparens][smartparens]]):

~sp-forward-slurp-sexp~ (from [[https://github.com/Fuco1/smartparens][smartparens]]): Add sexp following the
current list in it by moving the closing delimiter.

~sp-kill-sexp~ (from [[https://github.com/Fuco1/smartparens][smartparens]]):

~sp-next-sexp~ (from [[https://github.com/Fuco1/smartparens][smartparens]]): Move forward to the beginning of next
balanced expression.

~sp-raise-sexp~ (from [[https://github.com/Fuco1/smartparens][smartparens]]):

** customized
*** my-org-table-previous-row
~my-org-table-previous-row~: Go to the previous row (same column) in the
current table.

#+BEGIN_SRC emacs-lisp
(defun my-org-table-previous-row ()
  "Go to the previous row (same column) in the current table.
Before doing so, re-align the table if necessary."
  (interactive)
  (unless (org-at-table-hline-p)
    (org-table-maybe-eval-formula)
    (org-table-maybe-recalculate-line))
  (if (and org-table-automatic-realign
           org-table-may-need-update)
      (org-table-align))
  (let ((col (org-table-current-column)))
    (when (and (org-at-table-p)
               (not (= (org-table-current-line) 1)))
      (previous-line)
      (unless (org-at-table-hline-p)
        (org-table-goto-column col)))))
#+END_SRC

*** ta-avy-copy-sexp
~ta-avy-copy-sexp~: Copy ta point a visible sexp selected with ~avy~.

#+BEGIN_SRC emacs-lisp
(require 'avy)
(require 'smartparens)

(defun ta-avy-copy-sexp ()
  "Copy at point a visible sexp selected with `avy'."
  (interactive)
  (let ((initial-window (selected-window)))
    (save-excursion
      (call-interactively 'avy-goto-word-or-subword-1)
      (sp-copy-sexp))
    (select-window initial-window)
    (yank)))
#+END_SRC

*** ta-avy-goto-end-of-line
~ta-avy-goto-end-of-line~: Jump to the visible end of line.

#+BEGIN_SRC emacs-lisp
(require 'avy)

(defun ta-avy-goto-end-of-line ()
  "Jump to the visible end of line.
Call `avy-goto-char' with \"\n\" as argument."
  (interactive)
  (avy-goto-char ?\n))
#+END_SRC

*** ta-below-new-indent
~ta-below-new-indent~: Add an empty line below and move the cursor to
this line.

#+BEGIN_SRC emacs-lisp
(defun ta-below-new-indent ()
  "Add an empty line below and move the cursor to this line."
  (interactive)
  (end-of-line)
  (newline-and-indent))
#+END_SRC

*** ta-kill-whole-line
~ta-kill-whole-line~: Kill the whole current line.

#+BEGIN_SRC emacs-lisp
(defun ta-kill-whole-line ()
  "Kill the whole current line.
Preserve the column position of the cursor."
  (interactive)
  (let ((column-position (current-column)))
    (kill-whole-line)
    (move-to-column column-position)))
#+END_SRC

*** ta-mark-inside-dwim
~ta-mark-inside-dwim~: Mark things inside quotes if point is inside a
string.

#+BEGIN_SRC emacs-lisp
(require 'expand-region)
(require 'smartparens)

(defun ta-mark-inside-org-table ()
  "Mark current field inside org-table."
  (interactive)
  (when (org-at-table-p)
    (push-mark (point))
    (re-search-forward "|")
    (backward-char)
    (skip-chars-backward " ")
    (push-mark (point))
    (set-mark (point))
    (org-table-beginning-of-field 1)))

(defun ta-mark-inside-pairs ()
  "An other way to do `er/mark-inside-pairs' but work for sgml-tag too."
  (interactive)
  (ta-goto-begining-of-string (point))
  (sp-backward-up-sexp)
  (sp-mark-sexp)
  (sp-down-sexp)
  (exchange-point-and-mark)
  (sp-backward-down-sexp)
  (exchange-point-and-mark))

(defun ta-mark-inside-dwim (&optional arg)
  "Mark things inside quotes if point is inside a string.

If not inside string, mark inside table field in `org-mode'.
In other modes, mark things inside pairs.
If call two times consecutively mark inside pairs."
  (interactive)
  (cond ((equal last-command 'ta-mark-inside-dwim)
         (call-interactively 'ta-mark-inside-pairs))
        ((er--point-inside-string-p)
         (call-interactively 'er/mark-inside-quotes))
        ((and (equal major-mode 'org-mode) (org-at-table-p))
         (ta-mark-inside-org-table))
        (t (call-interactively 'ta-mark-inside-pairs))))

#+END_SRC

*** ta-mark-sexp-at-point
~ta-mark-sexp-at-point~: Mark the ~sexp~ at point.

#+BEGIN_SRC emacs-lisp
(require 'smartparens)

(defun ta--point-at-beginnig-sp-sexp-p ()
  "Return non-nil if `point' is at the beginning of a sp-sexp

and :op non empty. See `sp-get-thing'."
  (let ((ok (sp-get-thing)))
    (when ok
      (when (and (eq (point) (sp-get ok :beg))
                 (not (string-empty-p (sp-get ok :op))))
        (point)))))

(defun ta--mark-sexp-at-point ()
  "Mark the `sexp' at point."
  (let ((sexp-beg (beginning-of-thing 'sexp))
        (sexp-end (end-of-thing 'sexp)))
    (goto-char sexp-end)
    (set-mark sexp-end)
    (goto-char sexp-beg)))

(defun ta-mark-sexp-at-point ()
  "Mark the `sexp' at point. See `sexp-at-point' and `sp-mark-sexp'
(smartparens packages)."
  (interactive)
  (if (or (ta--point-at-beginnig-sp-sexp-p)
          (eq (following-char) ?<))
      (sp-mark-sexp)
    (if (eq (preceding-char) ?\")
        (progn
          (sp-backward-sexp)
          (sp-mark-sexp))
      (if (and (memq (following-char) '(32 ?\) ?\] ?\} ?>))
               (looking-back "[[:alnum:]]" 1))
          (backward-char 1))
      (ta--mark-sexp-at-point))))
#+END_SRC

* Emacs Lisp

- ~command-remapping~: Return the remapping for command COMMAND.
- ~org-at-table-hline-p~: Non-nil when point is inside a hline in a
  table.
- ~org-at-table-p~: Non-nil if the cursor is inside an Org table.
- ~org-table-current-column~: Return current column number.
- ~org-table-current-line~: Return the index of the current data line.
- ~org-table-goto-column~: Move the cursor to the Nth column in the
  current table line.
- ~org-table-maybe-eval-formula~: Check if the current field starts with
  "==" or ":==". If yes, store the formula and apply it.
- ~org-table-maybe-recalculate-line~: Recompute the current line if
  marked for it, and if we haven't just done it.
