#+TITLE: Inside Emacs
#+AUTHOR: Tony aldon
#+DATE: <2022-05-10 Tue>

* [2021-07-23 Fri] Use the result of a Python source-block in a table formula | org-table | Inside Emacs #6 (part 14)
:PROPERTIES:
:YOUTUBE_TITLE: Use the result of a Python source-block in a table formula | org-table | Inside Emacs #6 (part 14)
:YOUTUBE_LINK: https://youtu.be/ay7zslbSFqg
:YOUTUBE_UPLOAD_DATE: [2021-07-23 Fri]
:CONFIG_REPO:   https://github.com/tonyaldon/emacs.d
:CONFIG_COMMIT: 08912d6e6ef29158d1fa8ebbb98d90214ddc805e
:VIDEO_SCR_DIR: [[./src/inside-emacs-06-part-14/]]
:END:
** Built-in commands
*** global-map

- ~backward-kill-word~ (~M-DEL~): Kill characters backward until
  encountering the beginning of a word.
- ~kill-ring-save~ (~M-w~): Save the region as if killed, but don’t kill
  it.
- ~universal-argument~ (~C-u~): Begin a numeric argument for the following
  command.

*** org-mode-map

- ~org-ctrl-c-ctrl-c~ (~C-c C-c~): Set tags in headline, or update
  according
- ~org-mark-element~ (~M-h~): Put point at beginning of this element, mark
  at end.
- ~org-yank~ (~C-y~): Yank.  If the kill is a subtree, treat it
  specially.

** External commands

- ~avy-goto-line~ (from [[https://github.com/abo-abo/avy][avy]]): Jump to a line start in current buffer.
- ~avy-goto-char~ (from [[https://github.com/abo-abo/avy][avy]]): Jump to the currently visible char (read
  in the minibuffer).

** Customized commands
*** handy-mark-pop-local

~handy-mark-pop-local~: Jump to local mark.

#+BEGIN_SRC emacs-lisp
(defun handy-mark-pop-local ()
  "Jump to local mark."
  (interactive)
  (set-mark-command t))
#+END_SRC

*** ta-avy-goto-end-of-line

~ta-avy-goto-end-of-line~: Jump to the visible end of line.

#+BEGIN_SRC emacs-lisp
(require 'avy)

(defun ta-avy-goto-end-of-line ()
  "Jump to the visible end of line.
Call `avy-goto-char' with \"\n\" as argument."
  (interactive)
  (avy-goto-char ?\n))
#+END_SRC

** Emacs Lisp

- ~format~: Format a string out of a format-string and arguments.
- ~org-sbe~: Return the results of calling SOURCE-BLOCK with VARIABLES.

* [2021-07-20 Tue] Paycheck calculation using org-lookup-first | org-table | Inside Emacs #6 (part 13)
:PROPERTIES:
:YOUTUBE_TITLE: Paycheck calculation using org-lookup-first | org-table | Inside Emacs #6 (part 13)
:YOUTUBE_LINK: https://youtu.be/w3LbuI5naMI
:YOUTUBE_UPLOAD_DATE: [2021-07-20 Tue]
:CONFIG_REPO:   https://github.com/tonyaldon/emacs.d
:CONFIG_COMMIT: 08912d6e6ef29158d1fa8ebbb98d90214ddc805e
:VIDEO_SCR_DIR: [[./src/inside-emacs-06-part-13/]]
:END:
** Built-in commands
*** global-map

- ~isearch-forward~ (~C-s~): Do incremental search forward.
- ~kill-ring-save~ (~M-w~): Save the region as if killed, but don’t kill
  it.

*** org-mode-map

- ~org-set-property~ (~C-c C-x p~): In the current entry, set a property
  read in the minibuffer with a value read in the minibuffer.
- ~org-edit-special~ (~C-c '~): Call a special editor for the element at point.
- ~org-ctrl-c-ctrl-c~ (~C-c C-c~): Set tags in headline, or update according
- ~org-yank~ (~C-y~): Yank.  If the kill is a subtree, treat it specially.
- ~org-cycle~ (~TAB~): TAB-action and visibility cycling for Org mode.
- ~org-mark-element~ (~M-h~): Put point at beginning of this element, mark at end.

*** org-table-fedit-map

- ~org-table-fedit-finish~ (~C-c '~): Parse the buffer for formula
  definitions and install them.

** External commands

- ~avy-goto-char~ (from [[https://github.com/abo-abo/avy][avy]]): Jump to the currently visible char (read
  in the minibuffer).
- ~avy-goto-line~ (from [[https://github.com/abo-abo/avy][avy]]): Jump to a line start in current buffer.
- ~mc/mark-previous-like-this-word~ (from [[https://github.com/magnars/multiple-cursors.el][multiple-cursors]]): Find and
  mark the previous part of the buffer matching the currently active
  region.

** Customized commands
*** handy-expand-region-dwim

~handy-expand-region-dwim~: If region is active, call
~er/expand-region~.  If not call ~er/mark-word~.

#+BEGIN_SRC emacs-lisp
(require 'expand-region)

(defun handy-expand-region-dwim (arg)
  "If region is active, call `er/expand-region'.  If not call `er/mark-word'."
  (interactive "p")
  (if (or (region-active-p) (equal last-command this-command))
      (er/expand-region arg)
    (er/mark-word)
    (if (equal arg 4) (exchange-point-and-mark))))
#+END_SRC

*** handy-mark-dwim

~handy-mark-dwim~: Mark the url, sexp or sentence at point.

#+BEGIN_SRC emacs-lisp
(require 'smartparens)
(require 'expand-region)

(defun handy-point-in-url-p ()
  "Return the url at `point' if `point' is in an url."
  (thing-at-point 'url))

(defun handy-point-at-beginning-of-sexp-delimited-by-pairs-p ()
  "Return t if point is at beginning of sexp delimited by pairs."
  (let ((sexp (sp-get-thing)))
    (and (eq (point) (sp-get sexp :beg))
         (not (string-empty-p (sp-get sexp :op))))))

(defun handy-mark-sexp-at-point ()
  "Mark the `sexp' at point."
  (let ((sexp-beg (beginning-of-thing 'sexp))
        (sexp-end (end-of-thing 'sexp)))
    (goto-char sexp-end)
    ;; HACK: Have to use both `push-mark' and `set-mark' in this order to
    ;;       expected result.
    (push-mark sexp-end)
    (set-mark sexp-end)
    (goto-char sexp-beg)))

(defun handy-mark-dwim (arg)
  "Mark the url, sexp or sentence at point.

If point is in a url, call `er/mark-url'.  If not mark sexp at point.
If call 2 times consecutively, call `er/mark-sentence'."
  (interactive "p")
  (cond
   ((equal last-command this-command)
    (er/mark-sentence))
   ((handy-point-in-url-p)
    (er/mark-url))
   ((or (handy-point-at-beginning-of-sexp-delimited-by-pairs-p)
        (eq (following-char) ?<))
    (sp-mark-sexp))
   ((eq (preceding-char) ?\")
    (sp-backward-sexp)
    (sp-mark-sexp))
   ((and (memq (following-char) '(32 ?\) ?\] ?\} ?>))
         (looking-back "[[:alnum:]]" 1))
    (backward-char 1)
    (handy-mark-sexp-at-point))
   (t (handy-mark-sexp-at-point)))
  (if (equal arg 4) (exchange-point-and-mark)))
#+END_SRC

*** ta-avy-goto-end-of-line

~ta-avy-goto-end-of-line~: Jump to the visible end of line.

#+BEGIN_SRC emacs-lisp
(require 'avy)

(defun ta-avy-goto-end-of-line ()
  "Jump to the visible end of line.
Call `avy-goto-char' with \"\n\" as argument."
  (interactive)
  (avy-goto-char ?\n))
#+END_SRC

** Emacs Lisp

- ~org-lookup-first~: Find first occurrence of VAL in S-LIST; return
  corresponding element of R-LIST.
- ~org-lookup-last~: Find last occurrence of VAL in S-LIST; return
  corresponding element of R-LIST.
- ~org-lookup-all~: Find all occurrences of VAL in S-LIST; return
  corresponding elements of R-LIST.

* [2021-07-18 Sun] Calc formulas, all you need to know | org-table | Inside Emacs #6 (part 12)
:PROPERTIES:
:YOUTUBE_TITLE: Calc formulas, all you need to know | org-table | Inside Emacs #6 (part 12)
:YOUTUBE_LINK: https://youtu.be/afsBtpEfoG4
:YOUTUBE_UPLOAD_DATE: [2021-07-18 Sun]
:CONFIG_REPO:   https://github.com/tonyaldon/emacs.d
:CONFIG_COMMIT: 08912d6e6ef29158d1fa8ebbb98d90214ddc805e
:VIDEO_SCR_DIR: [[./src/inside-emacs-06-part-12/]]
:END:
** Built-in commands
*** global-map

- ~info~ (~C-h i~): Enter Info, the documentation browser.
- ~isearch-forward~ (~C-s~): Do incremental search forward.
- ~recenter-top-bottom~ (~C-l~): Scroll the window so that current line is
  in the middle of the window.

*** Info-mode-map

- ~Info-goto-node~ (~g~): Go to Info node read in the minibuffer.

*** org-mode-map

- ~org-yank~ (~C-y~): Yank.  If the kill is a subtree, treat it
  specially.
- ~org-return~ (~RET~): Goto next table row or insert a newline.

*** calc-dispatch

- ~calc-dispatch~ (~C-x *~): Invoke the GNU Emacs Calculator.
- ~quick-calc~ (~C-x * q~): Do a quick calculation in the minibuffer
  without invoking full Calculator.

*** calc-alg-ent-map

- ~calcAlg-enter~ (~C-j~): Insert calc calculation in the current buffer.

** External commands

- ~counsel-M-x~ (from [[https://github.com/abo-abo/swiper][counsel]]): Ivy version of
  ~execute-extended-command~.

* [2021-07-14 Wed] Editing formulas at the speed of light | org-table | Inside Emacs #6 (part 11)
:PROPERTIES:
:YOUTUBE_TITLE: Editing formulas at the speed of light | org-table | Inside Emacs #6 (part 11)
:YOUTUBE_LINK: https://youtu.be/0HgoHiqboc4
:YOUTUBE_UPLOAD_DATE: [2021-07-14 Wed]
:CONFIG_REPO:   https://github.com/tonyaldon/emacs.d
:CONFIG_COMMIT: 08912d6e6ef29158d1fa8ebbb98d90214ddc805e
:VIDEO_SCR_DIR: [[./src/inside-emacs-06-part-11/]]
:END:
** Built-in commands
*** without default key binding

- ~kill-word~: Kill characters forward until encountering the end of a word.

*** global-map

- ~forward-word~ (~M-f~): Move point forward word.
- ~universal-argument~ (~C-u~): Begin a numeric argument for the following
  command.
- ~move-end-of-line~ (~C-e~): Move point to end of current line as
  displayed.
- ~isearch-forward~ (~C-s~): Do incremental search forward.

*** minibuffer-local-map

- ~previous-history-element~ (~M-p~): Puts previous element of the
  minibuffer history in the minibuffer.
- ~next-history-element~ (~M-n~): Puts next element of the minibuffer
  history in the minibuffer.

*** org-mode-map

- ~org-cycle~ (~TAB~): TAB-action and visibility cycling for Org mode.
- ~org-return~ (~RET~): Goto next table row or insert a newline.
- ~org-table-field-info~ (~C-c ?~): Show info about the current field, and
  highlight any reference at point.
- ~org-ctrl-c-ctrl-c~ (~C-c C-c~): Set tags in headline, or update
  according
- ~org-table-eval-formula~ (~C-c =~): Replace the table field value at the
  cursor by the result of a calculation.
- ~org-table-toggle-coordinate-overlays~ (~C-c }~): Toggle the display of
  Row/Column numbers in tables.
- ~org-metaup~ (~M-<up>~): Move subtree up or move table row up.
- ~org-metaright~ (~M-<right>~): Demote heading, list item at point or
  move table column right.
- ~org-shiftmetaleft~ (~M-S-<left>~): Promote subtree or delete table
  column.
- ~org-edit-special~ (~C-c '~): Call a special editor for the element at
  point.

*** org-table-fedit-map

- ~org-table-fedit-finish~ (~C-c '~): Parse the buffer for formula
  definitions and install them.
- ~org-table-fedit-abort~ (~C-c C-q~): Abort editing formulas, without
  installing the changes.
- ~org-table-fedit-ref-right~ (~S-<right>~): Shift the reference at point
  one field to the right.
- ~org-table-fedit-ref-down~ (~S-<down>~): Shift the reference at point
  one row/hline down.

** External commands

- ~avy-goto-char~ (from [[https://github.com/abo-abo/avy][avy]]): Jump to the currently visible char (read
  in the minibuffer).

* [2021-07-07 Wed] Field substitution in Emacs Lisp Formulas | org-table | Inside Emacs #6 (part 10)
:PROPERTIES:
:YOUTUBE_TITLE: Field substitution in Emacs Lisp Formulas | org-table | Inside Emacs #6 (part 10)
:YOUTUBE_LINK: https://youtu.be/w3V8-_qjYgI
:YOUTUBE_UPLOAD_DATE: [2021-07-07 Wed]
:CONFIG_REPO:   https://github.com/tonyaldon/emacs.d
:CONFIG_COMMIT: 15379cdd5e548f1540d677d4386bb5da7d5bc5b0
:VIDEO_SCR_DIR: [[./src/inside-emacs-06-part-10/]]
:END:
** Built-in commands
*** without default key binding

- ~eval-defun~: Evaluate the top-level form containing point, or after
  point.

*** global-map

- ~delete-other-windows~ (~C-x 1~): Make selected window fill its frame.
- ~eval-last-sexp~ (~C-x C-e~): Evaluate sexp before point; print value in
  the echo area.
- ~isearch-forward~ (~C-s~): Do incremental search forward.
- ~previous-buffer~ (~C-x <left>~): In selected window switch to previous
  buffer.

*** isearch-mode-map

- ~isearch-query-replace-regexp~ (~C-M-%~): Start ~query-replace-regexp~
  with string to replace from last search string.

*** org-mode-map

- ~org-ctrl-c-ctrl-c~ (~C-c C-c~): Set tags in headline, or update according
- ~org-table-toggle-formula-debugger~ (~C-c {~): Toggle the formula
  debugger in tables.

** External commands

- ~counsel-find-file~ (from [[https://github.com/abo-abo/swiper][swiper]]): Forward to ~find-file~.
- ~sp-backward-up-sexp~ (from [[https://github.com/Fuco1/smartparens][smartparens]]): Move backward out of one
  level of parentheses.

** Customized commands
*** handy-add-space

~handy-add-space~: Add space at point without moving.

#+BEGIN_SRC emacs-lisp
(defun handy-add-space ()
  "Add space at point without moving."
  (interactive)
  (insert " ")
  (goto-char (- (point) 1)))
#+END_SRC

*** handy-avy-copy-past-sexp

~handy-avy-copy-past-sexp~: Past sexp copied using ~avy~ at current
cursor position.

#+BEGIN_SRC emacs-lisp
(require 'avy)
(require 'smartparens)

(defun handy-avy-copy-past-sexp ()
  "Past sexp copied using `avy' at current cursor position."
  (interactive)
  (let ((initial-window (selected-window)))
    (save-excursion
      (call-interactively 'avy-goto-word-or-subword-1)
      (sp-copy-sexp))
    (select-window initial-window)
    (yank)))
#+END_SRC

*** ta-eval-expression

~ta-eval-expression~: Call ~eval-expression~.  If called with universal
argument, call ~pp-eval-expression~.

#+BEGIN_SRC emacs-lisp
(defun ta-eval-expression (&optional arg)
  "Call `eval-expression'.
If called with universal argument, call `pp-eval-expression'."
  (interactive "P")
  (if arg
      (call-interactively 'pp-eval-expression)
    (call-interactively 'eval-expression)))
#+END_SRC

*** handy-mark-line

~handy-mark-line~: Mark the current line.

#+BEGIN_SRC emacs-lisp
(defun handy-mark-line (arg)
  "Mark the current line.

If call with `universal-argument', copy the line."
  (interactive "p")
  (if (equal arg 4)
      (handy-line-copy)
    ;; HACK: Have to use both `push-mark' and `set-mark' in this order
    ;;       to get expected result.
    (end-of-line)
    (push-mark (point))
    (set-mark (point))
    (beginning-of-line)))
#+END_SRC
** Emacs Lisp

- ~+~: Return sum of any number of arguments, which are numbers or
  markers.
- ~string-to-number~: Parse STRING as a decimal number and return the
  number.
- ~upcase~: Convert argument to upper case and return that.
- ~intern~: Return the canonical symbol whose name is STRING.
- ~type-of~: Return a symbol representing the type of OBJECT.
- ~funcall~: Call first argument as a function, passing remaining
  arguments to it.

* [2021-07-02 Fri] The bases of the ORG SPREADSHEET | org-table | Inside Emacs #6 (part 9)
:PROPERTIES:
:YOUTUBE_TITLE: The bases of the ORG SPREADSHEET | org-table | Inside Emacs #6 (part 9)
:YOUTUBE_LINK: https://youtu.be/wrEYankhAIs
:YOUTUBE_UPLOAD_DATE: [2021-07-02 Fri]
:CONFIG_REPO:   https://github.com/tonyaldon/emacs.d
:CONFIG_COMMIT: 15379cdd5e548f1540d677d4386bb5da7d5bc5b0
:VIDEO_SCR_DIR: [[./src/inside-emacs-06-part-09/]]
:END:
** Built-in commands
*** org-mode-map

- ~org-ctrl-c-ctrl-c~ (~C-c C-c~): Set tags in headline, or update
  according to changed information at point.
- ~org-yank~ (~C-y~): Yank.  If the kill is a subtree, treat it
  specially.

** Customized commands
*** handy-mark-line

~handy-mark-line~: Mark the current line.

#+BEGIN_SRC emacs-lisp
(defun handy-mark-line (arg)
  "Mark the current line.

If call with `universal-argument', copy the line."
  (interactive "p")
  (if (equal arg 4)
      (handy-line-copy)
    ;; HACK: Have to use both `push-mark' and `set-mark' in this order
    ;;       to get expected result.
    (end-of-line)
    (push-mark (point))
    (set-mark (point))
    (beginning-of-line)))
#+END_SRC

*** ta-avy-goto-end-of-line

~ta-avy-goto-end-of-line~: Jump to the visible end of line.

#+BEGIN_SRC emacs-lisp
(require 'avy)

(defun ta-avy-goto-end-of-line ()
  "Jump to the visible end of line.
Call `avy-goto-char' with \"\n\" as argument."
  (interactive)
  (avy-goto-char ?\n))
#+END_SRC

* [2021-06-17 Thu] Produce html tables in seconds with orgtbl-mode | org-table | Inside Emacs #6 (part 8)
:PROPERTIES:
:YOUTUBE_TITLE: Produce html tables in seconds with orgtbl-mode | org-table | Inside Emacs #6 (part 8)
:YOUTUBE_LINK: https://www.youtube.com/watch?v=JyG54FFWu-o
:YOUTUBE_UPLOAD_DATE: [2021-06-17 Thu]
:CONFIG_REPO:   https://github.com/tonyaldon/emacs.d
:CONFIG_COMMIT: 06ba16e26da4fbedb430090287aec096bf491037
:VIDEO_SCR_DIR: [[./src/inside-emacs-06-part-08/]]
:END:
** Built-in commands
*** without default key binding

- ~org-table-transpose-table-at-point~: Transpose Org table at point and
  eliminate hlines.
- ~orgtbl-insert-radio-table~: Insert a radio table template appropriate
  for this major mode.
- ~orgtbl-mode~: Toggle ~orgtbl-mode~ mode.

*** global-map

- ~recenter-top-bottom~ (~C-l~): Scroll the window so that current line is
  in the middle of the window.

*** orgtbl-mode-map

- ~orgtbl-hijacker-command-4~ (~M-S-<right>~): In tables, run
  ~org-table-insert-column~.  Outside of tables, run the binding of
  ~M-S-<right>~.
- ~orgtbl-hijacker-command-100~ (~<return>~): In tables, run
  ~orgtbl-ret~. Outside of tables, run the binding of ~<return>~ or ~RET~.
- ~orgtbl-hijacker-command-102~ (~<tab>~): In tables, run
  ~orgtbl-tab~. Outside of tables, run the binding of ~<tab>~ or ~TAB~.
- ~orgtbl-hijacker-command-17~ (~S-<return>~): In tables, run
  ~org-table-copy-down~.  Outside of tables, run the binding of
  ~S-<return>~.
- ~orgtbl-hijacker-command-109~ (~<backspace>~): In tables, run
  ~org-delete-backward-char~.  Outside of tables, run the binding of
  ~<backspace>~ or ~DEL~.
- ~orgtbl-ctrl-c-ctrl-c~ (~C-c C-c~): If the cursor is inside a table,
  realign the table.  If it is a table to be sent away to a receiver,
  do it.  With universal argument, also recompute table.

** External commands

- ~counsel-M-x~ (from [[https://github.com/abo-abo/swiper][counsel]]): Ivy version of
  ~execute-extended-command~.
- ~counsel-yank-pop~ (from [[https://github.com/abo-abo/swiper][swiper]]): Ivy replacement for ~yank-pop~.

** Customized commands
*** ta-avy-goto-end-of-line

~ta-avy-goto-end-of-line~: Jump to the visible end of line.

#+BEGIN_SRC emacs-lisp
(require 'avy)

(defun ta-avy-goto-end-of-line ()
  "Jump to the visible end of line.
Call `avy-goto-char' with \"\n\" as argument."
  (interactive)
  (avy-goto-char ?\n))
#+END_SRC

** Emacs Lisp

- ~orgtbl-radio-table-templates~: Templates for radio tables in
  different major modes.
- ~advice-add~: Like ~add-function~ but for the function named SYMBOL.
- ~inhibit-message~: Non-nil means calls to ~message~ are not displayed.
- ~indent-region~: Indent each nonblank line in the region.

* [2021-06-16 Wed] Use custom formats to export Org tables to HTML tables | org-table | Inside Emacs #6 (part 7)
:PROPERTIES:
:YOUTUBE_TITLE: Use custom formats to export Org tables to HTML tables | org-table | Inside Emacs #6 (part 7)
:YOUTUBE_LINK: https://www.youtube.com/watch?v=LogbcVWb3mQ
:YOUTUBE_UPLOAD_DATE: [2021-06-16 Wed]
:CONFIG_REPO:   https://github.com/tonyaldon/emacs.d
:CONFIG_COMMIT: 06ba16e26da4fbedb430090287aec096bf491037
:VIDEO_SCR_DIR: [[./src/inside-emacs-06-part-07/]]
:END:
** Built-in commands
*** without default key binding

- ~isearch-occur~: Run ~occur~ using the last search string as the
  regexp.

*** global-map

- ~eval-last-sexp~ (~C-x C-e~): Evaluate sexp before point; print value in
  the echo area.
- ~narrow-to-region~ (~C-x n n~): Restrict editing in this buffer to the
  current region.
- ~recenter-top-bottom~ (~C-l~): Scroll the window so that current line is
  in the middle of the window.
- ~isearch-forward~ (~C-s~): Do incremental search forward.

*** org-mode-map

- ~org-edit-special~ (~C-c '~): Call a special editor for the element at
  point.

*** org-src-mode-map

- ~org-edit-src-exit~ (~C-c '~): Kill current sub-editing buffer and
  return to source buffer.

*** org-mode

- ~org-table-export~: Export table to a file, with configurable format.

** External commands

- ~avy-goto-char~ (from [[https://github.com/abo-abo/avy][avy]]): Jump to the currently visible char (read
  in the minibuffer).
- ~avy-goto-line~ (from [[https://github.com/abo-abo/avy][avy]]): Jump to a line start in current buffer.
- ~avy-goto-line~ (from [[https://github.com/abo-abo/avy][avy]]): Jump to a line start in current buffer.
- ~counsel-M-x~ (from [[https://github.com/abo-abo/swiper][counsel]]): Ivy version of ~execute-extended-command~.
- ~counsel-yank-pop~ (from [[https://github.com/abo-abo/swiper][swiper]]): Ivy replacement for ~yank-pop~.
- ~sp-next-sexp~ (from [[https://github.com/Fuco1/smartparens][smartparens]]): Move forward to the beginning of
  next balanced expression.
- ~yas-expand~ (from [[https://github.com/joaotavora/yasnippet][yasnippet]]): Expand a snippet before point.

** Customized commands
*** handy-expand-region-dwim

~handy-expand-region-dwim~: If region is active, call
~er/expand-region~.  If not call ~er/mark-word~.

#+BEGIN_SRC emacs-lisp
(require 'expand-region)

(defun handy-expand-region-dwim (arg)
  "If region is active, call `er/expand-region'.  If not call `er/mark-word'."
  (interactive "p")
  (if (or (region-active-p) (equal last-command this-command))
      (er/expand-region arg)
    (er/mark-word)
    (if (equal arg 4) (exchange-point-and-mark))))
#+END_SRC

*** handy-mark-dwim

~handy-mark-dwim~: Mark the url, sexp or sentence at point.

#+BEGIN_SRC emacs-lisp
(require 'smartparens)
(require 'expand-region)

(defun handy-point-in-url-p ()
  "Return the url at `point' if `point' is in an url."
  (thing-at-point 'url))

(defun handy-point-at-beginning-of-sexp-delimited-by-pairs-p ()
  "Return t if point is at beginning of sexp delimited by pairs."
  (let ((sexp (sp-get-thing)))
    (and (eq (point) (sp-get sexp :beg))
         (not (string-empty-p (sp-get sexp :op))))))

(defun handy-mark-sexp-at-point ()
  "Mark the `sexp' at point."
  (let ((sexp-beg (beginning-of-thing 'sexp))
        (sexp-end (end-of-thing 'sexp)))
    (goto-char sexp-end)
    ;; HACK: Have to use both `push-mark' and `set-mark' in this order to
    ;;       expected result.
    (push-mark sexp-end)
    (set-mark sexp-end)
    (goto-char sexp-beg)))

(defun handy-mark-dwim (arg)
  "Mark the url, sexp or sentence at point.

If point is in a url, call `er/mark-url'.  If not mark sexp at point.
If call 2 times consecutively, call `er/mark-sentence'."
  (interactive "p")
  (cond
   ((equal last-command this-command)
    (er/mark-sentence))
   ((handy-point-in-url-p)
    (er/mark-url))
   ((or (handy-point-at-beginning-of-sexp-delimited-by-pairs-p)
        (eq (following-char) ?<))
    (sp-mark-sexp))
   ((eq (preceding-char) ?\")
    (sp-backward-sexp)
    (sp-mark-sexp))
   ((and (memq (following-char) '(32 ?\) ?\] ?\} ?>))
         (looking-back "[[:alnum:]]" 1))
    (backward-char 1)
    (handy-mark-sexp-at-point))
   (t (handy-mark-sexp-at-point)))
  (if (equal arg 4) (exchange-point-and-mark)))
#+END_SRC

*** handy-mark-inside-dwim

~handy-mark-inside-dwim~: Mark things inside quotes if point is inside
a string.

#+BEGIN_SRC emacs-lisp
(require 'smartparens)
(require 'expand-region)

(defun handy-mark-inside-field ()
  "Mark current field inside org-table."
  (interactive)
  (when (org-at-table-p)
    (push-mark (point))
    (re-search-forward "|")
    (backward-char)
    (skip-chars-backward " ")
    (push-mark (point))
    (set-mark (point))
    (org-table-beginning-of-field 1)))

(defun handy-mark-inside-pairs ()
  "An other way to do `er/mark-inside-pairs' but work for sgml-tag too."
  (interactive)
  (handy-mark-goto-beginning-of-string (point))
  ;; todo: do thing when inside a tag <tag name="tony"> (maybe use the function sgml-begining-of-tag)
  (sp-backward-up-sexp)
  (sp-mark-sexp)
  (sp-down-sexp)
  (exchange-point-and-mark)
  (sp-backward-down-sexp)
  (exchange-point-and-mark))

(defun handy-mark-inside-dwim (&optional arg)
  "Mark things inside quotes if point is inside a string.

If not inside string, mark inside table field in `org-mode'.
In other modes, mark things inside pairs.
If call two times consecutively mark inside pairs."
  (interactive)
  (cond ((equal last-command this-command)
         (call-interactively 'handy-mark-inside-pairs))
        ((er--point-inside-string-p)
         (call-interactively 'er/mark-inside-quotes))
        ((and (equal major-mode 'org-mode) (org-at-table-p))
         (handy-mark-inside-field))
        (t (call-interactively 'handy-mark-inside-pairs))))
#+END_SRC

*** insight-scroll-up-half-window

~insight-scroll-up-half-window~: Scroll up of half window height.

#+BEGIN_SRC emacs-lisp
(defun insight--half-window-height ()
  "Compute half window height."
  (/ (window-body-height) 2))

(defun insight-scroll-up-half-window ()
  "Scroll up of half window height."
  (interactive)
  (scroll-up (insight--half-window-height)))
#+END_SRC

*** ta-avy-goto-end-of-line

~ta-avy-goto-end-of-line~: Jump to the visible end of line.

#+BEGIN_SRC emacs-lisp
(require 'avy)

(defun ta-avy-goto-end-of-line ()
  "Jump to the visible end of line.
Call `avy-goto-char' with \"\n\" as argument."
  (interactive)
  (avy-goto-char ?\n))
#+END_SRC

*** ta-describe-thing-at-point

~ta-describe-thing-at-point~: Display the full documentation of the
~thing-at-point~.

#+BEGIN_SRC emacs-lisp
(defun ta-describe-thing-at-point ()
  "Display the full documentation of the `thing-at-point'.

Return nil if the symbol of the `thing-at-point' is neither a function
nor a variable."
  (interactive)
  (when-let* ((symbol (symbol-at-point))
              (symbol-n (symbol-name symbol)))
    (when (and (eq major-mode 'org-mode)
               (s-starts-with-p "~" symbol-n)
               (s-ends-with-p "~" symbol-n))
      (setq symbol (->> symbol-n
                        (s-chop-prefix "~")
                        (s-chop-suffix "~")
                        (intern))))
    (describe-symbol symbol)))
#+END_SRC

** Emacs Lisp

- ~orgtbl-to-generic~: Convert the orgtbl-mode TABLE to some other
  format.
- ~orgtbl-to-html~: Convert the orgtbl-mode TABLE to HTML.
- ~org-export-define-backend~: Define a new back-end BACKEND.
- ~org-export-options-alist~: Alist between export properties and ways
  to set them.

* [2021-06-12 Sat] Export Org tables to HTML tables | org-table | Inside Emacs #6 (part 6)
:PROPERTIES:
:YOUTUBE_TITLE: Export Org tables to HTML tables | org-table | Inside Emacs #6 (part 6)
:YOUTUBE_LINK: https://www.youtube.com/watch?v=loa1g9wwNlI
:YOUTUBE_UPLOAD_DATE: [2021-06-12 Sat]
:CONFIG_REPO:   https://github.com/tonyaldon/emacs.d
:CONFIG_COMMIT: 06ba16e26da4fbedb430090287aec096bf491037
:VIDEO_SCR_DIR: [[./src/inside-emacs-06-part-06/]]
:END:
** Built-in
*** org-mode-map

- ~org-cycle~ (~TAB~): TAB-action and visibility cycling for Org mode.
- ~org-set-property~ (~C-c C-x p~): In the current entry, set a property
  read in the minibuffer with a value read in the minibuffer.
- ~org-shiftmetaright~ (~M-S-<right>~): Demote subtree or insert table
  column.

*** org-mode

- ~org-table-export~: Export table to a file, with configurable format.

** External commands

- ~avy-goto-char~ (from [[https://github.com/abo-abo/avy][avy]]): Jump to the currently visible char (read
  in the minibuffer).
- ~avy-goto-line~ (from [[https://github.com/abo-abo/avy][avy]]): Jump to a line start in current buffer.
- ~counsel-M-x~ (from [[https://github.com/abo-abo/swiper][counsel]]): Ivy version of ~execute-extended-command~.
- ~counsel-find-file~ (from [[https://github.com/abo-abo/swiper][swiper]]): Forward to ~find-file~.

** Customized
*** handy-expand-region-dwim

~handy-expand-region-dwim~: If region is active, call
~er/expand-region~.  If not call ~er/mark-word~.

#+BEGIN_SRC emacs-lisp
(require 'expand-region)

(defun handy-expand-region-dwim (arg)
  "If region is active, call `er/expand-region'.  If not call `er/mark-word'."
  (interactive "p")
  (if (or (region-active-p) (equal last-command this-command))
      (er/expand-region arg)
    (er/mark-word)
    (if (equal arg 4) (exchange-point-and-mark))))
#+END_SRC

*** handy-mark-dwim

~handy-mark-dwim~: Mark the url, sexp or sentence at point.

#+BEGIN_SRC emacs-lisp
(require 'smartparens)
(require 'expand-region)

(defun handy-point-in-url-p ()
  "Return the url at `point' if `point' is in an url."
  (thing-at-point 'url))

(defun handy-point-at-beginning-of-sexp-delimited-by-pairs-p ()
  "Return t if point is at beginning of sexp delimited by pairs."
  (let ((sexp (sp-get-thing)))
    (and (eq (point) (sp-get sexp :beg))
         (not (string-empty-p (sp-get sexp :op))))))

(defun handy-mark-sexp-at-point ()
  "Mark the `sexp' at point."
  (let ((sexp-beg (beginning-of-thing 'sexp))
        (sexp-end (end-of-thing 'sexp)))
    (goto-char sexp-end)
    ;; HACK: Have to use both `push-mark' and `set-mark' in this order to
    ;;       expected result.
    (push-mark sexp-end)
    (set-mark sexp-end)
    (goto-char sexp-beg)))

(defun handy-mark-dwim (arg)
  "Mark the url, sexp or sentence at point.

If point is in a url, call `er/mark-url'.  If not mark sexp at point.
If call 2 times consecutively, call `er/mark-sentence'."
  (interactive "p")
  (cond
   ((equal last-command this-command)
    (er/mark-sentence))
   ((handy-point-in-url-p)
    (er/mark-url))
   ((or (handy-point-at-beginning-of-sexp-delimited-by-pairs-p)
        (eq (following-char) ?<))
    (sp-mark-sexp))
   ((eq (preceding-char) ?\")
    (sp-backward-sexp)
    (sp-mark-sexp))
   ((and (memq (following-char) '(32 ?\) ?\] ?\} ?>))
         (looking-back "[[:alnum:]]" 1))
    (backward-char 1)
    (handy-mark-sexp-at-point))
   (t (handy-mark-sexp-at-point)))
  (if (equal arg 4) (exchange-point-and-mark)))
#+END_SRC

*** handy-mark-line

~handy-mark-line~: Mark the current line.

#+BEGIN_SRC emacs-lisp
(defun handy-mark-line (arg)
  "Mark the current line.

If call with `universal-argument', copy the line."
  (interactive "p")
  (if (equal arg 4)
      (handy-line-copy)
    ;; HACK: Have to use both `push-mark' and `set-mark' in this order
    ;;       to get expected result.
    (end-of-line)
    (push-mark (point))
    (set-mark (point))
    (beginning-of-line)))
#+END_SRC

*** insight-scroll-up-half-window

~insight-scroll-up-half-window~: Scroll up of half window height.

#+BEGIN_SRC emacs-lisp
(defun insight--half-window-height ()
  "Compute half window height."
  (/ (window-body-height) 2))

(defun insight-scroll-up-half-window ()
  "Scroll up of half window height."
  (interactive)
  (scroll-up (insight--half-window-height)))
#+END_SRC

*** ta-describe-thing-at-point

~ta-describe-thing-at-point~: Display the full documentation of the
~thing-at-point~.

#+BEGIN_SRC emacs-lisp
(defun ta-describe-thing-at-point ()
  "Display the full documentation of the `thing-at-point'.

Return nil if the symbol of the `thing-at-point' is neither a function
nor a variable."
  (interactive)
  (when-let* ((symbol (symbol-at-point))
              (symbol-n (symbol-name symbol)))
    (when (and (eq major-mode 'org-mode)
               (s-starts-with-p "~" symbol-n)
               (s-ends-with-p "~" symbol-n))
      (setq symbol (->> symbol-n
                        (s-chop-prefix "~")
                        (s-chop-suffix "~")
                        (intern))))
    (describe-symbol symbol)))
#+END_SRC

*** ta-org-shiftmetadown

~ta-org-shiftmetadown~: Drag the line at point down.

#+BEGIN_SRC emacs-lisp
(require 'org)

(defun ta-org-shiftmetadown (&optional _arg)
  "Drag the line at point down.
In a table, insert an empty row below the current line (this part
differs from the original `org-shiftmetadown' command).
On a clock timestamp, update the value of the timestamp like `S-<down>'
but also adjust the previous clocked item in the clock history.
Everywhere else, drag the line at point down."
  (interactive "P")
  (cond
   ((run-hook-with-args-until-success 'org-shiftmetadown-hook))
   ((org-at-table-p) (org-table-insert-row 'below))
   ((org-at-clock-log-p) (let ((org-clock-adjust-closest t))
                           (call-interactively 'org-timestamp-down)))
   (t (call-interactively 'org-drag-line-forward))))
#+END_SRC

** Emacs Lisp

- ~orgtbl-to-generic~: Convert the orgtbl-mode TABLE to some other
  format.
- ~orgtbl-to-tsv~: Convert the orgtbl-mode table to TAB separated
  material.

* [2020-12-29 Tue] Very fast editing of tables | org-table | Inside Emacs #6 (part 5)
:PROPERTIES:
:YOUTUBE_TITLE: Very fast editing of tables | org-table | Inside Emacs #6 (part 5)
:YOUTUBE_LINK: https://youtu.be/w4wxGOijyZs
:YOUTUBE_UPLOAD_DATE: [2020-12-29 Tue]
:CONFIG_REPO:   https://github.com/tonyaldon/emacs.d
:CONFIG_COMMIT: 852afb87e258c90a8e79a026dae369272b3b5280
:VIDEO_SCR_DIR: [[./src/inside-emacs-06-part-05/]]
:END:
** Built-in commands
*** global-map

- ~eval-expression~ (~M-:~): Read an Emacs Lisp expression in the
  minibuffer and evaluate it.

*** org-mode-map

- ~org-cycle~ (~TAB~): TAB-action and visibility cycling for Org mode.
- ~org-metadown~ (~M-<down>~): Move subtree down or move table row down.
- ~org-metaleft~ (~M-<left>~): Promote heading, list item at point or move
  table column left.
- ~org-metaright~ (~M-<right>~): Demote heading, list item at point or
  move table column right.
- ~org-metaup~ (~M-<up>~): Move subtree up or move table row up.
- ~org-return~ (~RET~): Goto next table row or insert a newline.
- ~org-shiftdown~ (~S-<down>~): Act on current element according to
  context.  Call ~org-timestamp-down~ or ~org-priority-down~, or
  ~org-next-item~, or ~org-table-move-cell-down~.
- ~org-shiftleft~ (~S-<left>~): Act on current element according to
  context.  This does one of the following: 1) switch a timestamp at
  point one day into the past, 2) on a headline, switch to the
  previous TODO keyword, 3) on an item, switch entire list to the
  previous bullet type, 4) on a property line, switch to the previous
  allowed value, 5) on a clocktable definition line, move time block
  into the past, 6) in a table, move a single cell left,
- ~org-shiftmetadown~ (~M-S-<down>~): Drag the line at point down.  In a
  table, insert an empty row at the current line.  On a clock
  timestamp, update the value of the timestamp like ~S-<down>~ but also
  adjust the previous clocked item in the clock history.
- ~org-shiftmetaleft~ (~M-S-<left>~): Promote subtree or delete table column.
- ~org-shiftmetaright~ (~M-S-<right>~): Demote subtree or insert table column.
- ~org-shiftmetaup~ (~M-S-<up>~): Drag the line at point up.  In a table,
  kill the current row.  On a clock timestamp, update the value of the
  timestamp like ~S-<up>~ but also adjust the previous clocked item in
  the clock history.
- ~org-shiftright~ (~S-<right>~): Act on the current element according to
  context.  This does one of the following: 1) switch a timestamp at
  point one day into the future, 2) on a headline, switch to the next
  TODO keyword, 3) on an item, switch entire list to the next bullet
  type, 4) on a property line, switch to the next allowed value, 5) on
  a clocktable definition line, move time block into the future, 6) in
  a table, move a single cell right,
- ~org-shifttab~ (~S-TAB~): Global visibility cycling or move to previous
  table field.
- ~org-shiftup~ (~S-<up>~): Act on current element according to
  context. Call ~org-timestamp-up~ or ~org-priority-up~, or
  ~org-previous-item~, or ~org-table-move-cell-up~.
- ~org-table-blank-field~ (~C-SPC~): Blank the current table field or
  active region.
- ~org-table-copy-down~ (~S-RET~): Copy the value of the current field one
  row below.

** External commands

- ~avy-goto-char~ (from [[https://github.com/abo-abo/avy][avy]]): Jump to the currently visible char (read
  in the minibuffer).

** Customized commands
*** ta-mark-inside-dwim

~ta-mark-inside-dwim~: Mark things inside quotes if point is inside a
string.

#+BEGIN_SRC emacs-lisp
(require 'expand-region)
(require 'smartparens)

(defun ta-mark-inside-org-table ()
  "Mark current field inside org-table."
  (interactive)
  (when (org-at-table-p)
    (push-mark (point))
    (re-search-forward "|")
    (backward-char)
    (skip-chars-backward " ")
    (push-mark (point))
    (set-mark (point))
    (org-table-beginning-of-field 1)))

(defun ta-mark-inside-pairs ()
  "An other way to do `er/mark-inside-pairs' but work for sgml-tag too."
  (interactive)
  (ta-goto-begining-of-string (point))
  (sp-backward-up-sexp)
  (sp-mark-sexp)
  (sp-down-sexp)
  (exchange-point-and-mark)
  (sp-backward-down-sexp)
  (exchange-point-and-mark))

(defun ta-mark-inside-dwim (&optional arg)
  "Mark things inside quotes if point is inside a string.

If not inside string, mark inside table field in `org-mode'.
In other modes, mark things inside pairs.
If call two times consecutively mark inside pairs."
  (interactive)
  (cond ((equal last-command 'ta-mark-inside-dwim)
         (call-interactively 'ta-mark-inside-pairs))
        ((er--point-inside-string-p)
         (call-interactively 'er/mark-inside-quotes))
        ((and (equal major-mode 'org-mode) (org-at-table-p))
         (ta-mark-inside-org-table))
        (t (call-interactively 'ta-mark-inside-pairs))))

#+END_SRC

*** ta-mark-sexp-at-point

~ta-mark-sexp-at-point~: Mark the ~sexp~ at point.

#+BEGIN_SRC emacs-lisp
(require 'smartparens)

(defun ta--point-at-beginnig-sp-sexp-p ()
  "Return non-nil if `point' is at the beginning of a sp-sexp

and :op non empty. See `sp-get-thing'."
  (let ((ok (sp-get-thing)))
    (when ok
      (when (and (eq (point) (sp-get ok :beg))
                 (not (string-empty-p (sp-get ok :op))))
        (point)))))

(defun ta--mark-sexp-at-point ()
  "Mark the `sexp' at point."
  (let ((sexp-beg (beginning-of-thing 'sexp))
        (sexp-end (end-of-thing 'sexp)))
    (goto-char sexp-end)
    (set-mark sexp-end)
    (goto-char sexp-beg)))

(defun ta-mark-sexp-at-point ()
  "Mark the `sexp' at point. See `sexp-at-point' and `sp-mark-sexp'
(smartparens packages)."
  (interactive)
  (if (or (ta--point-at-beginnig-sp-sexp-p)
          (eq (following-char) ?<))
      (sp-mark-sexp)
    (if (eq (preceding-char) ?\")
        (progn
          (sp-backward-sexp)
          (sp-mark-sexp))
      (if (and (memq (following-char) '(32 ?\) ?\] ?\} ?>))
               (looking-back "[[:alnum:]]" 1))
          (backward-char 1))
      (ta--mark-sexp-at-point))))
#+END_SRC

*** ta-org-table-previous-row

~ta-org-table-previous-row~: Go to the previous row (same column) in the
current table.

#+BEGIN_SRC emacs-lisp
(defun ta-org-table-previous-row ()
  "Go to the previous row (same column) in the current table.
Before doing so, re-align the table if necessary."
  (interactive)
  (unless (org-at-table-hline-p)
    (org-table-maybe-eval-formula)
    (org-table-maybe-recalculate-line))
  (if (and org-table-automatic-realign
           org-table-may-need-update)
      (org-table-align))
  (let ((col (org-table-current-column)))
    (when (and (org-at-table-p)
               (not (= (org-table-current-line) 1)))
      (previous-line)
      (unless (org-at-table-hline-p)
        (org-table-goto-column col)))))
#+END_SRC

** Emacs Lisp

- ~org-table-auto-blank-field~: Non-nil means automatically blank table
  field when starting to type into it.
- ~org-table-copy-increment~: Non-nil means increment when copying
  current field with ~org-table-copy-down~.

* [2020-12-26 Sat] Copy and paste tables | org-table | Inside Emacs #6 (part 4)
:PROPERTIES:
:YOUTUBE_TITLE: Copy and paste tables | org-table | Inside Emacs #6 (part 4)
:YOUTUBE_LINK: https://youtu.be/0fbrVArRxUo
:YOUTUBE_UPLOAD_DATE: [2020-12-26 Sat]
:CONFIG_REPO:   https://github.com/tonyaldon/emacs.d
:CONFIG_COMMIT: 124a1958e4e222722980ced00724f0ee7c948575
:VIDEO_SCR_DIR: [[./src/inside-emacs-06-part-04/]]
:END:
** Built-in commands
*** global-map

- ~undo~ (~C-x u~): Undo some previous changes.

*** org-mode-map

- ~org-ctrl-c-ctrl-c~ (~C-c C-c~): Set tags in headline, or update according to changed information at point.
- ~org-ctrl-c-minus~ (~C-c -~): Insert separator line in table or modify bullet status of line.
- ~org-ctrl-c-ret~ (~C-c RET~): Call ~org-table-hline-and-move~ or ~org-insert-heading~.
- ~org-cycle~ (~TAB~): TAB-action and visibility cycling for Org mode.
- ~org-forward-sentence~ (~M-e~): Go to end of sentence, or end of table field.
- ~org-return~ (~RET~): Goto next table row or insert a newline.
- ~org-shiftmetaright~ (~M-S-<right>~): Demote subtree or insert table column.
- ~org-shifttab~ (~S-TAB~): Global visibility cycling or move to previous table field.
- ~org-sort~ (~C-c ^~): Call ~org-sort-entries~, ~org-table-sort-lines~ or ~org-sort-list~.
- ~org-table-hline-and-move~ (~C-c RET~): Insert a hline and move to the row below that line.

*** org-mode

- ~org-table-copy-region~: Copy rectangular region in table to clipboard.
- ~org-table-paste-rectangle~: Paste a rectangular region into a table.

** External commands

~avy-goto-char~ (from [[https://github.com/abo-abo/avy][avy]]): Jump to the currently visible char (read in
the minibuffer).

* [2020-12-24 Thu] Tweak the command org-meta-return | org-table | Inside Emacs #6 (part 3)
:PROPERTIES:
:YOUTUBE_TITLE: Tweak the command org-meta-return | org-table | Inside Emacs #6 (part 3)
:YOUTUBE_LINK: https://youtu.be/KxOwKK5sXRA
:YOUTUBE_UPLOAD_DATE: [2020-12-24 Thu]
:CONFIG_REPO:   https://github.com/tonyaldon/emacs.d
:CONFIG_COMMIT: 124a1958e4e222722980ced00724f0ee7c948575
:VIDEO_SCR_DIR: [[./src/inside-emacs-06-part-03/]]
:END:
** Built-in commands
*** without default key binding

- ~eval-defun~: Evaluate the top-level form containing point, or after
  point.
- ~join-line~: Join this line to previous and fix up whitespace at
  join.

*** global-map

- ~previous-buffer~ (~C-x <left>~): In selected window switch to previous
  buffer.
- ~repeat~ (~C-x z~): Repeat most recently executed command.
- ~undo~ (~C-x u~): Undo some previous changes.

*** org-mode-map

- ~org-ctrl-c-ctrl-c~ (~C-c C-c~): Set tags in headline, or update
  according to changed information at point.
- ~org-meta-return~ (~<M-return>~): Insert a new heading or wrap a region
  in a table.
- ~org-return~ (~RET~): Goto next table row or insert a newline.

*** org-mode

- ~org-table-wrap-region~: Wrap several fields in a column like a
  paragraph.

** External commands

- ~avy-goto-char~ (from [[https://github.com/abo-abo/avy][avy]]): Jump to the currently visible char (read
  in the minibuffer).
- ~avy-goto-line~ (from [[https://github.com/abo-abo/avy][avy]]): Jump to a line start in current buffer.
- ~mc/mark-next-like-this~ (from [[https://github.com/magnars/multiple-cursors.el][multiple-cursors]]): Find and mark the
  next part of the buffer matching the currently active region.
- ~yas-expand~ (from [[https://github.com/joaotavora/yasnippet][yasnippet]]): Expand a snippet before point.
- ~sp-backward-up-sexp~ (from [[https://github.com/Fuco1/smartparens][smartparens]]): Move backward out of one
  level of parentheses.
- ~sp-forward-slurp-sexp~ (from [[https://github.com/Fuco1/smartparens][smartparens]]): Add sexp following the
  current list in it by moving the closing delimiter.

** Customized commands
*** my-org-meta-return

~my-org-meta-return~: Insert a new heading or wrap a region in a table.

#+BEGIN_SRC emacs-lisp
(defun my-org-meta-return (&optional arg)
  "Insert a new heading or wrap a region in a table.
Calls `org-insert-heading', `org-insert-item' or
`org-table-wrap-region', depending on context."
  (interactive "P")
  (org-check-before-invisible-edit 'insert)
  (or (run-hook-with-args-until-success 'org-metareturn-hook)
      (if (org-at-table-p)
          (org-table-wrap-region arg)
        (call-interactively
         (cond (arg #'org-insert-heading)
               ((org-in-item-p) #'org-insert-item)
               (t #'org-insert-heading))))))
#+END_SRC

*** ta-avy-copy-sexp

~ta-avy-copy-sexp~: Copy ta point a visible sexp selected with ~avy~.

#+BEGIN_SRC emacs-lisp
(require 'avy)
(require 'smartparens)

(defun ta-avy-copy-sexp ()
  "Copy at point a visible sexp selected with `avy'."
  (interactive)
  (let ((initial-window (selected-window)))
    (save-excursion
      (call-interactively 'avy-goto-word-or-subword-1)
      (sp-copy-sexp))
    (select-window initial-window)
    (yank)))
#+END_SRC

*** ta-avy-goto-end-of-line

~ta-avy-goto-end-of-line~: Jump to the visible end of line.

#+BEGIN_SRC emacs-lisp
(require 'avy)

(defun ta-avy-goto-end-of-line ()
  "Jump to the visible end of line.
Call `avy-goto-char' with \"\n\" as argument."
  (interactive)
  (avy-goto-char ?\n))
#+END_SRC

*** ta-kill-whole-line

~ta-kill-whole-line~: Kill the whole current line.

#+BEGIN_SRC emacs-lisp
(defun ta-kill-whole-line ()
  "Kill the whole current line.
Preserve the column position of the cursor."
  (interactive)
  (let ((column-position (current-column)))
    (kill-whole-line)
    (move-to-column column-position)))
#+END_SRC

*** ta-mark-inside-dwim

~ta-mark-inside-dwim~: Mark things inside quotes if point is inside a
string.

#+BEGIN_SRC emacs-lisp
(require 'expand-region)
(require 'smartparens)

(defun ta-mark-inside-org-table ()
  "Mark current field inside org-table."
  (interactive)
  (when (org-at-table-p)
    (push-mark (point))
    (re-search-forward "|")
    (backward-char)
    (skip-chars-backward " ")
    (push-mark (point))
    (set-mark (point))
    (org-table-beginning-of-field 1)))

(defun ta-mark-inside-pairs ()
  "An other way to do `er/mark-inside-pairs' but work for sgml-tag too."
  (interactive)
  (ta-goto-begining-of-string (point))
  (sp-backward-up-sexp)
  (sp-mark-sexp)
  (sp-down-sexp)
  (exchange-point-and-mark)
  (sp-backward-down-sexp)
  (exchange-point-and-mark))

(defun ta-mark-inside-dwim (&optional arg)
  "Mark things inside quotes if point is inside a string.

If not inside string, mark inside table field in `org-mode'.
In other modes, mark things inside pairs.
If call two times consecutively mark inside pairs."
  (interactive)
  (cond ((equal last-command 'ta-mark-inside-dwim)
         (call-interactively 'ta-mark-inside-pairs))
        ((er--point-inside-string-p)
         (call-interactively 'er/mark-inside-quotes))
        ((and (equal major-mode 'org-mode) (org-at-table-p))
         (ta-mark-inside-org-table))
        (t (call-interactively 'ta-mark-inside-pairs))))

#+END_SRC

*** ta-mark-sexp-at-point

~ta-mark-sexp-at-point~: Mark the sexp at point

#+BEGIN_SRC emacs-lisp
(require 'smartparens)

(defun ta--point-at-beginnig-sp-sexp-p ()
  "Return non-nil if `point' is at the beginning of a sp-sexp

and :op non empty. See `sp-get-thing'."
  (let ((ok (sp-get-thing)))
    (when ok
      (when (and (eq (point) (sp-get ok :beg))
                 (not (string-empty-p (sp-get ok :op))))
        (point)))))

(defun ta--mark-sexp-at-point ()
  "Mark the `sexp' at point."
  (let ((sexp-beg (beginning-of-thing 'sexp))
        (sexp-end (end-of-thing 'sexp)))
    (goto-char sexp-end)
    (set-mark sexp-end)
    (goto-char sexp-beg)))

(defun ta-mark-sexp-at-point ()
  "Mark the `sexp' at point. See `sexp-at-point' and `sp-mark-sexp'
(smartparens packages)."
  (interactive)
  (if (or (ta--point-at-beginnig-sp-sexp-p)
          (eq (following-char) ?<))
      (sp-mark-sexp)
    (if (eq (preceding-char) ?\")
        (progn
          (sp-backward-sexp)
          (sp-mark-sexp))
      (if (and (memq (following-char) '(32 ?\) ?\] ?\} ?>))
               (looking-back "[[:alnum:]]" 1))
          (backward-char 1))
      (ta--mark-sexp-at-point))))
#+END_SRC

*** ta-org-table-previous-row

~ta-org-table-previous-row~: Go to the previous row (same column) in
the current table.

#+BEGIN_SRC emacs-lisp
(defun ta-org-table-previous-row ()
  "Go to the previous row (same column) in the current table.
Before doing so, re-align the table if necessary."
  (interactive)
  (unless (org-at-table-hline-p)
    (org-table-maybe-eval-formula)
    (org-table-maybe-recalculate-line))
  (if (and org-table-automatic-realign
           org-table-may-need-update)
      (org-table-align))
  (let ((col (org-table-current-column)))
    (when (and (org-at-table-p)
               (not (= (org-table-current-line) 1)))
      (previous-line)
      (unless (org-at-table-hline-p)
        (org-table-goto-column col)))))
#+END_SRC

** Emacs Lisp

- ~call-interactively~: Call FUNCTION, providing args according to its
  interactive calling specs.
- ~define-key~: In KEYMAP, define key sequence KEY as DEF.
- ~org-at-table-p~: Non-nil if the cursor is inside an Org table.
- ~org-in-item-p~: Return item beginning position when in a plain list,
  nil otherwise.
- ~org-insert-heading~: Insert a new heading or an item with the same
  depth at point.
- ~org-insert-item~: Insert a new item at the current level.

* [2020-12-19 Sat] Move through an org table | org-table | Inside Emacs #6 (part 2)
:PROPERTIES:
:YOUTUBE_TITLE: Move through an org table | org-table | Inside Emacs #6 (part 2)
:YOUTUBE_LINK: https://youtu.be/RhwCClMdaps
:YOUTUBE_UPLOAD_DATE: [2020-12-19 Sat]
:CONFIG_REPO:   https://github.com/tonyaldon/emacs.d
:CONFIG_COMMIT: 6982f26e031a6aaa82515274d8572204fffaec56
:VIDEO_SCR_DIR: [[./src/inside-emacs-06-part-02/]]
:END:
** Built-in commands
*** without default key binding

- ~eval-defun~: Evaluate the top-level form containing point, or after
  point.
- ~join-line~: Join this line to previous and fix up whitespace at
  join.

*** global-map

- ~eval-expression~ (~M-:~): Read an Emacs Lisp expression in the
  minibuffer and evaluate it.
- ~kill-ring-save~ (~M-w~): Save the region as if killed, but don’t kill
  it.
- ~next-buffer~ (~C-x <right>~): In selected window switch to next
  buffer.
- ~previous-buffer~ (~C-x <left>~): In selected window switch to previous
  buffer.

*** org-mode-map

- ~org-backward-sentence~ (~M-a~): Go to beginning of sentence, or
  beginning of table field.
- ~org-forward-sentence~ (~M-e~): Go to end of sentence, or end of table
  field.
- ~org-cycle~ (~TAB~): TAB-action and visibility cycling for Org mode.
- ~org-return~ (~RET~): Goto next table row or insert a newline.
- ~org-shifttab~ (~S-TAB~): Global visibility cycling or move to previous
  table field.

** External commands

- ~avy-goto-char~ (from [[https://github.com/abo-abo/avy][avy]]): Jump to the currently visible char (read
  in the minibuffer).
- ~avy-goto-line~ (from [[https://github.com/abo-abo/avy][avy]]): Jump to a line start in current buffer.
- ~er/expand-region~ (from [[https://github.com/magnars/expand-region.el][expand-region]]): Increase selected region by
  semantic units.
- ~iy-go-to-char~ (from [[https://github.com/doitian/iy-go-to-char][iy-go-to-char]]):  Move forward to next char read
  in the minibuffer.
- ~mc/mark-next-like-this-word~ (from [[https://github.com/magnars/multiple-cursors.el][multiple-cursors]]): Find and mark
  the next part of the buffer matching the currently active region.
- ~sp-backward-sexp~ (from [[https://github.com/Fuco1/smartparens][smartparens]]): Move backward across one
  balanced expression (sexp).
- ~sp-backward-up-sexp~ (from [[https://github.com/Fuco1/smartparens][smartparens]]): Move backward out of one
  level of parentheses.
- ~sp-forward-slurp-sexp~ (from [[https://github.com/Fuco1/smartparens][smartparens]]): Add sexp following the
  current list in it by moving the closing delimiter.
- ~sp-kill-sexp~ (from [[https://github.com/Fuco1/smartparens][smartparens]]): Kill the balanced expression
  following point.
- ~sp-next-sexp~ (from [[https://github.com/Fuco1/smartparens][smartparens]]): Move forward to the beginning of
  next balanced expression.
- ~sp-raise-sexp~ (from [[https://github.com/Fuco1/smartparens][smartparens]]): Unwrap the current list and kill
  everything inside except next expression.

** Customized commands
*** my-org-table-previous-row

~my-org-table-previous-row~: Go to the previous row (same column) in the
current table.

#+BEGIN_SRC emacs-lisp
(defun my-org-table-previous-row ()
  "Go to the previous row (same column) in the current table.
Before doing so, re-align the table if necessary."
  (interactive)
  (unless (org-at-table-hline-p)
    (org-table-maybe-eval-formula)
    (org-table-maybe-recalculate-line))
  (if (and org-table-automatic-realign
           org-table-may-need-update)
      (org-table-align))
  (let ((col (org-table-current-column)))
    (when (and (org-at-table-p)
               (not (= (org-table-current-line) 1)))
      (previous-line)
      (unless (org-at-table-hline-p)
        (org-table-goto-column col)))))
#+END_SRC

*** ta-avy-copy-sexp

~ta-avy-copy-sexp~: Copy ta point a visible sexp selected with ~avy~.

#+BEGIN_SRC emacs-lisp
(require 'avy)
(require 'smartparens)

(defun ta-avy-copy-sexp ()
  "Copy at point a visible sexp selected with `avy'."
  (interactive)
  (let ((initial-window (selected-window)))
    (save-excursion
      (call-interactively 'avy-goto-word-or-subword-1)
      (sp-copy-sexp))
    (select-window initial-window)
    (yank)))
#+END_SRC

*** ta-avy-goto-end-of-line

~ta-avy-goto-end-of-line~: Jump to the visible end of line.

#+BEGIN_SRC emacs-lisp
(require 'avy)

(defun ta-avy-goto-end-of-line ()
  "Jump to the visible end of line.
Call `avy-goto-char' with \"\n\" as argument."
  (interactive)
  (avy-goto-char ?\n))
#+END_SRC

*** ta-below-new-indent

~ta-below-new-indent~: Add an empty line below and move the cursor to
this line.

#+BEGIN_SRC emacs-lisp
(defun ta-below-new-indent ()
  "Add an empty line below and move the cursor to this line."
  (interactive)
  (end-of-line)
  (newline-and-indent))
#+END_SRC

*** ta-kill-whole-line

~ta-kill-whole-line~: Kill the whole current line.

#+BEGIN_SRC emacs-lisp
(defun ta-kill-whole-line ()
  "Kill the whole current line.
Preserve the column position of the cursor."
  (interactive)
  (let ((column-position (current-column)))
    (kill-whole-line)
    (move-to-column column-position)))
#+END_SRC

*** ta-mark-inside-dwim

~ta-mark-inside-dwim~: Mark things inside quotes if point is inside a
string.

#+BEGIN_SRC emacs-lisp
(require 'expand-region)
(require 'smartparens)

(defun ta-mark-inside-org-table ()
  "Mark current field inside org-table."
  (interactive)
  (when (org-at-table-p)
    (push-mark (point))
    (re-search-forward "|")
    (backward-char)
    (skip-chars-backward " ")
    (push-mark (point))
    (set-mark (point))
    (org-table-beginning-of-field 1)))

(defun ta-mark-inside-pairs ()
  "An other way to do `er/mark-inside-pairs' but work for sgml-tag too."
  (interactive)
  (ta-goto-begining-of-string (point))
  (sp-backward-up-sexp)
  (sp-mark-sexp)
  (sp-down-sexp)
  (exchange-point-and-mark)
  (sp-backward-down-sexp)
  (exchange-point-and-mark))

(defun ta-mark-inside-dwim (&optional arg)
  "Mark things inside quotes if point is inside a string.

If not inside string, mark inside table field in `org-mode'.
In other modes, mark things inside pairs.
If call two times consecutively mark inside pairs."
  (interactive)
  (cond ((equal last-command 'ta-mark-inside-dwim)
         (call-interactively 'ta-mark-inside-pairs))
        ((er--point-inside-string-p)
         (call-interactively 'er/mark-inside-quotes))
        ((and (equal major-mode 'org-mode) (org-at-table-p))
         (ta-mark-inside-org-table))
        (t (call-interactively 'ta-mark-inside-pairs))))

#+END_SRC

*** ta-mark-sexp-at-point

~ta-mark-sexp-at-point~: Mark the ~sexp~ at point.

#+BEGIN_SRC emacs-lisp
(require 'smartparens)

(defun ta--point-at-beginnig-sp-sexp-p ()
  "Return non-nil if `point' is at the beginning of a sp-sexp

and :op non empty. See `sp-get-thing'."
  (let ((ok (sp-get-thing)))
    (when ok
      (when (and (eq (point) (sp-get ok :beg))
                 (not (string-empty-p (sp-get ok :op))))
        (point)))))

(defun ta--mark-sexp-at-point ()
  "Mark the `sexp' at point."
  (let ((sexp-beg (beginning-of-thing 'sexp))
        (sexp-end (end-of-thing 'sexp)))
    (goto-char sexp-end)
    (set-mark sexp-end)
    (goto-char sexp-beg)))

(defun ta-mark-sexp-at-point ()
  "Mark the `sexp' at point. See `sexp-at-point' and `sp-mark-sexp'
(smartparens packages)."
  (interactive)
  (if (or (ta--point-at-beginnig-sp-sexp-p)
          (eq (following-char) ?<))
      (sp-mark-sexp)
    (if (eq (preceding-char) ?\")
        (progn
          (sp-backward-sexp)
          (sp-mark-sexp))
      (if (and (memq (following-char) '(32 ?\) ?\] ?\} ?>))
               (looking-back "[[:alnum:]]" 1))
          (backward-char 1))
      (ta--mark-sexp-at-point))))
#+END_SRC

** Emacs Lisp

- ~command-remapping~: Return the remapping for command COMMAND.
- ~org-at-table-hline-p~: Non-nil when point is inside a hline in a
  table.
- ~org-at-table-p~: Non-nil if the cursor is inside an Org table.
- ~org-table-current-column~: Return current column number.
- ~org-table-current-line~: Return the index of the current data line.
- ~org-table-goto-column~: Move the cursor to the Nth column in the
  current table line.
- ~org-table-maybe-eval-formula~: Check if the current field starts with
  "==" or ":==". If yes, store the formula and apply it.
- ~org-table-maybe-recalculate-line~: Recompute the current line if
  marked for it, and if we haven't just done it.

* [2020-11-26 Thu] Create and import tables | org-table | Inside Emacs #6 (part 1)
:PROPERTIES:
:YOUTUBE_TITLE: Create and import tables | org-table | Inside Emacs #6 (part 1)
:YOUTUBE_LINK: https://youtu.be/pRXRwQ1GGr4
:YOUTUBE_UPLOAD_DATE: [2020-11-26 Thu]
:CONFIG_REPO:   https://github.com/tonyaldon/emacs.d
:CONFIG_COMMIT: fc02ec1c2d2caa52b22410adb465f79c115c7e2a
:VIDEO_SCR_DIR: [[./src/inside-emacs-06-part-01/]]
:END:
** Built-in
*** without default key binding

- ~whitespace-mode~: Toggle whitespace visualization (Whitespace mode).

*** global-map

- ~previous-buffer~ (~C-x <left>~): In selected window switch to previous
  buffer.
- ~universal-argument~ (~C-u~): Begin a numeric argument for the following
  command.

*** org-mode-map

- ~org-ctrl-c-ctrl-c~ (~C-c C-c~): Set tags in headline, or update
  according to changed information at point.
- ~org-cycle~ (~TAB~): TAB-action and visibility cycling for Org mode.
- ~org-return~ (~RET~): Goto next table row or insert a newline.
- ~org-table-create-or-convert-from-region~ (~C-|~): Convert region to
  table, or create an empty table.

** External

- ~avy-goto-line~ (from [[https://github.com/abo-abo/avy][avy]]): Jump to a line start in current buffer.
- ~csv-align-fields~ (from [[https://elpa.gnu.org/packages/csv-mode.html][csv-mode]]): Align all the fields in the region
  to form columns.
- ~er/expand-region~ (from [[https://github.com/magnars/expand-region.el][expand-region]]): Increase selected region by
  semantic units.
- ~er/expand-region~ (from [[https://github.com/magnars/expand-region.el][expand-region]]): Increase selected region by
  semantic units.
- ~tsv-mode~ (from [[https://elpa.gnu.org/packages/csv-mode.html][csv-mode]]): Major mode for editing files of
  tab-separated value type.

* [2020-09-11 Fri] Starting emacs daemon with systemd | Inside Emacs #5 (part 2)
:PROPERTIES:
:YOUTUBE_TITLE: Starting emacs daemon with systemd | Inside Emacs #5 (part 2)
:YOUTUBE_LINK: https://youtu.be/fg_jTo9SK9I
:YOUTUBE_UPLOAD_DATE: [2020-09-11 Fri]
:CONFIG_REPO:   https://github.com/tonyaldon/emacs.d
:CONFIG_COMMIT: 33c04510f94e5eb96ed7b072dfba410cbc70a9d0
:VIDEO_SCR_DIR: [[./src/inside-emacs-05-part-02/]]
:END:
** Commands

The commands used in the video are the following:

#+BEGIN_SRC bash
cd ~/.config/systemd/user
locate emacs.service
cp /usr/share/emacs/28.0.50/etc/emacs.service .
emacsclient -nw
emacsclient --eval "(kill-emacs)"
ps -ax | grep emacs
systemctl enable emacs --user
systemctl status emacs --user
systemctl start emacs --user
emacsclient -nc
#+END_SRC

* [2020-09-08 Tue] Getting started with Emacs client/server | Inside Emacs #5 (part 1)
:PROPERTIES:
:YOUTUBE_TITLE: Getting started with Emacs client/server | Inside Emacs #5 (part 1)
:YOUTUBE_LINK: https://youtu.be/kw4h2hYYq-o
:YOUTUBE_UPLOAD_DATE: [2020-09-08 Tue]
:CONFIG_REPO:   https://github.com/tonyaldon/emacs.d
:CONFIG_COMMIT: 33c04510f94e5eb96ed7b072dfba410cbc70a9d0
:END:
** Commands

The commands used in the video are the following:

#+BEGIN_SRC bash
emacsclient -h
emacsclient -nw
emacs --daemon
ps -aux | grep emacs
emacsclient --eval "(kill-emacs)"
man pidof
pidof emacs
ps -ax | grep emacs
emacs -nw
#+END_SRC

* [2020-08-28 Fri] company-mode, company-backends, frontend, company-active-map | Inside Emacs #4 (part 2)
:PROPERTIES:
:YOUTUBE_TITLE: company-mode, company-backends, frontend, company-active-map | Inside Emacs #4 (part 2)
:YOUTUBE_LINK: https://youtu.be/zSPraaX2524
:YOUTUBE_UPLOAD_DATE: [2020-08-28 Fri]
:CONFIG_REPO:   https://github.com/tonyaldon/emacs.d
:CONFIG_COMMIT: 4cbdb3ce735ae296387069ef7ff309f0cfa812e8
:VIDEO_SCR_DIR: [[./src/inside-emacs-04-part-02/]]
:END:
** Built-in commands
*** without default key binding

- ~eval-defun~: Evaluate the top-level form containing point, or after
  point.
- ~eval-region~: Execute the region as Lisp code.
- ~windmove-left~: Select the window to the left of the current one.
- ~windmove-right~: Select the window to the right of the current one.
- ~window-toggle-side-windows~: Toggle display of side windows on the
  current frame.

*** global-map

- ~delete-blank-lines~ (~C-x C-o~): On blank line, delete all
  surrounding blank lines, leaving just one.
- ~describe-variable~ (~C-h v~): Display the full documentation of
  variable read from the minibuffer.
- ~mark-paragraph~ (~M-h~): Put point at beginning of this paragraph,
  mark at end.
- ~next-buffer~ (~C-x <right>~): In selected window switch to next
  buffer.
- ~previous-buffer~ (~C-x <left>~): In selected window switch to
  previous buffer.
- ~revert-buffer~ (~C-x x g~): Replace current buffer text with the
  text of the visited file on disk.

** External commands

- ~avy-goto-word-or-subword-1~ (from [[https://github.com/abo-abo/avy][avy]]): Jump to the currently visible
  char (read in the minibuffer) at a subword or word start.
- ~counsel-M-x~ (from [[https://github.com/abo-abo/swiper][counsel]]): Ivy version of ~execute-extended-command~.
- ~sp-next-sexp~ (from [[https://github.com/Fuco1/smartparens][smartparens]]): Move forward to the beginning of
  next balanced expression.
- ~swiper~ (from [[https://github.com/abo-abo/swiper][swiper]]): ~isearch-forward~ with an overview.
- ~yas-expand~ (from [[https://github.com/joaotavora/yasnippet][yasnippet]]): Expand a snippet before point.

** Customized commands
*** ta-above-new-indent

~ta-above-new-indent~: Add an empty line above and move the cursor to
this line.

#+BEGIN_SRC emacs-lisp
(defun ta-above-new-indent ()
  "Add an empty line above and move the cursor to this line."
  (interactive)
  (back-to-indentation)
  (split-line))
#+END_SRC

*** ta-avy-goto-end-of-line

~ta-avy-goto-end-of-line~: Jump to the visible end of line.

#+BEGIN_SRC emacs-lisp
(require 'avy)

(defun ta-avy-goto-end-of-line ()
  "Jump to the visible end of line.
Call `avy-goto-char' with \"\n\" as argument."
  (interactive)
  (avy-goto-char ?\n))
#+END_SRC

*** ta-below-new-indent

~ta-below-new-indent~: Add an empty line below and move the cursor to
this line.

#+BEGIN_SRC emacs-lisp
(defun ta-below-new-indent ()
  "Add an empty line below and move the cursor to this line."
  (interactive)
  (end-of-line)
  (newline-and-indent))
#+END_SRC

*** ta-mark-sexp-at-point

~ta-mark-sexp-at-point~: Mark the ~sexp~ at point.

#+BEGIN_SRC emacs-lisp
(require 'smartparens)

(defun ta--point-at-beginnig-sp-sexp-p ()
  "Return non-nil if `point' is at the beginning of a sp-sexp

and :op non empty. See `sp-get-thing'."
  (let ((ok (sp-get-thing)))
    (when ok
      (when (and (eq (point) (sp-get ok :beg))
                 (not (string-empty-p (sp-get ok :op))))
        (point)))))

(defun ta--mark-sexp-at-point ()
  "Mark the `sexp' at point."
  (let ((sexp-beg (beginning-of-thing 'sexp))
        (sexp-end (end-of-thing 'sexp)))
    (goto-char sexp-end)
    (set-mark sexp-end)
    (goto-char sexp-beg)))

(defun ta-mark-sexp-at-point ()
  "Mark the `sexp' at point. See `sexp-at-point' and `sp-mark-sexp'
(smartparens packages)."
  (interactive)
  (if (or (ta--point-at-beginnig-sp-sexp-p)
          (eq (following-char) ?<))
      (sp-mark-sexp)
    (if (eq (preceding-char) ?\")
        (progn
          (sp-backward-sexp)
          (sp-mark-sexp))
      (if (and (memq (following-char) '(32 ?\) ?\] ?\} ?>))
               (looking-back "[[:alnum:]]" 1))
          (backward-char 1))
      (ta--mark-sexp-at-point))))
#+END_SRC

* [2020-08-23 Sun] company-mode, showcase, source code, faces | Inside Emacs #4 (part 1)
:PROPERTIES:
:YOUTUBE_TITLE: company-mode, showcase, source code, faces | Inside Emacs #4 (part 1)
:YOUTUBE_LINK: https://youtu.be/96jn5A73-oQ
:YOUTUBE_UPLOAD_DATE: [2020-08-23 Sun]
:CONFIG_REPO:   https://github.com/tonyaldon/emacs.d
:CONFIG_COMMIT: 4cbdb3ce735ae296387069ef7ff309f0cfa812e8
:VIDEO_SCR_DIR: [[./src/inside-emacs-04-part-01/]]
:END:
** Built-in commands
*** without default key binding

- ~eval-defun~: Evaluate the top-level form containing point, or after
  point.
- ~join-line~: Join this line to previous and fix up whitespace at
  join.

*** global-map

- ~delete-blank-lines~ (~C-x C-o~): On blank line, delete all surrounding
  blank lines, leaving just one.
- ~open-line~ (~C-o~): Insert a newline and leave point before it.

** External commands

- ~avy-goto-word-or-subword-1~ (from [[https://github.com/abo-abo/avy][avy]]): Jump to the currently visible
  char (read in the minibuffer) at a subword or word start.
- ~bicycle-cycle~ (from [[https://github.com/tarsius/bicycle][bicycle]]): Cycle local or global visibility.
- ~company-complete-selection~ (from [[https://github.com/company-mode/company-mode][company]]): Insert the selected candidate.
- ~company-filter-candidates~ (from [[https://github.com/company-mode/company-mode][company]]): Start filtering the
  completion candidates incrementally.
- ~counsel-outline~ (from [[https://github.com/abo-abo/swiper][counsel]]): Jump to an outline heading with completion.
- ~yas-expand~ (from [[https://github.com/joaotavora/yasnippet][yasnippet]]): Expand a snippet before point.
- ~sp-forward-slurp-sexp~ (from [[https://github.com/Fuco1/smartparens][smartparens]]): Add sexp following the
  current list in it by moving the closing delimiter.

** Customized commands
*** ta-avy-copy-sexp

~ta-avy-copy-sexp~: Copy ta point a visible sexp selected with ~avy~.

#+BEGIN_SRC emacs-lisp
(require 'avy)
(require 'smartparens)

(defun ta-avy-copy-sexp ()
  "Copy at point a visible sexp selected with `avy'."
  (interactive)
  (let ((initial-window (selected-window)))
    (save-excursion
      (call-interactively 'avy-goto-word-or-subword-1)
      (sp-copy-sexp))
    (select-window initial-window)
    (yank)))
#+END_SRC

*** ta-kill-whole-line

~ta-kill-whole-line~: Kill the whole current line.

#+BEGIN_SRC emacs-lisp
(defun ta-kill-whole-line ()
  "Kill the whole current line.
Preserve the column position of the cursor."
  (interactive)
  (let ((column-position (current-column)))
    (kill-whole-line)
    (move-to-column column-position)))
#+END_SRC

*** ta-mark-sexp-at-point

~ta-mark-sexp-at-point~: Mark the ~sexp~ at point.

#+BEGIN_SRC emacs-lisp
(require 'smartparens)

(defun ta--point-at-beginnig-sp-sexp-p ()
  "Return non-nil if `point' is at the beginning of a sp-sexp

and :op non empty. See `sp-get-thing'."
  (let ((ok (sp-get-thing)))
    (when ok
      (when (and (eq (point) (sp-get ok :beg))
                 (not (string-empty-p (sp-get ok :op))))
        (point)))))

(defun ta--mark-sexp-at-point ()
  "Mark the `sexp' at point."
  (let ((sexp-beg (beginning-of-thing 'sexp))
        (sexp-end (end-of-thing 'sexp)))
    (goto-char sexp-end)
    (set-mark sexp-end)
    (goto-char sexp-beg)))

(defun ta-mark-sexp-at-point ()
  "Mark the `sexp' at point. See `sexp-at-point' and `sp-mark-sexp'
(smartparens packages)."
  (interactive)
  (if (or (ta--point-at-beginnig-sp-sexp-p)
          (eq (following-char) ?<))
      (sp-mark-sexp)
    (if (eq (preceding-char) ?\")
        (progn
          (sp-backward-sexp)
          (sp-mark-sexp))
      (if (and (memq (following-char) '(32 ?\) ?\] ?\} ?>))
               (looking-back "[[:alnum:]]" 1))
          (backward-char 1))
      (ta--mark-sexp-at-point))))
#+END_SRC

*** ta-outline-toggle-global

~ta-outline-toggle-global~:  Toggle visibility of all outline
sections.  This is a variant off the ~bicycle-cycle-global~ with two
levels less.

#+BEGIN_SRC emacs-lisp
(require 'bicycle)

(defun ta-outline-toggle-global ()
  "Toggle visibility of all outline (see `outline-mode') sections.

This command toggle between this following levels:
1. TREES:    Show all headings, treaing top-level code blocks
             as sections (i.e. their first line is treated as
             a heading).
2. ALL:      Show everything, except code blocks that have been
             collapsed individually (using a `hideshow' command
             or function).

This is a variant off the `bicycle-cycle-global' with two
levels less."
  (interactive)
  (setq deactivate-mark t)
  (save-excursion
    (goto-char (point-min))
    (unless (re-search-forward outline-regexp nil t)
      (user-error "Found no heading"))
    (cond
     ((eq last-command 'outline-cycle-trees)
      (outline-show-all)
      (bicycle--message "ALL"))
     (t
      (outline-hide-sublevels (bicycle--level))
      (outline-map-region
       (lambda ()
         (when (bicycle--top-level-p)
           (outline-show-branches)))
       (point-min)
       (point-max))
      (bicycle--message "TREES")
      (setq this-command 'outline-cycle-trees)))))
#+END_SRC

*** ta-sidebar

~ta-sidebar~: Pop up a buffer on the left of the frame in ~dired-mode~.

#+BEGIN_SRC emacs-lisp
(require 'dired)
(require 'dired-hacks-utils)
(require 'dash)

(defun ta-dired-width (dir)
  "String length of the longest filename in DIR."
  (with-current-buffer (dired-noselect dir)
    (-max (--map (length (-last-item (s-split "/" it)))
                 (dired-utils-get-all-files)))))

(defun ta-sidebar ()
  "Pop up a buffer on the left of the frame in `dired-mode'.
If the frame contains buffers in `dired-mode', delete them."
  (interactive)
  (let ((initial-window (selected-window))
        dired-window-deleted-p
        buff-file-name)
    (--each (window-list)
      (select-window it)
      (if (string-equal major-mode "dired-mode")
          (progn (delete-window) (setq dired-window-deleted-p t))))
    (unless dired-window-deleted-p
      (select-window initial-window)
      (delete-other-windows)
      (setq buff-file-name
            (file-name-directory (cond (buffer-file-name) ("~/"))))
      (let ((width (ta-dired-width buff-file-name)))
        (split-window-right (+ 10 width))) ; 10 is arbitrary
      (dired buff-file-name))))
#+END_SRC

* [2020-08-13 Thu] other-window-scroll-buffer, mc/add-cursor-on-click, drag-stuff, smartparens | Inside Emacs #3
:PROPERTIES:
:YOUTUBE_TITLE: other-window-scroll-buffer, mc/add-cursor-on-click, drag-stuff, smartparens | Inside Emacs #3
:YOUTUBE_LINK: https://youtu.be/RFhay0n7JJo
:YOUTUBE_UPLOAD_DATE: [2020-08-13 Thu]
:CONFIG_REPO:   https://github.com/tonyaldon/emacs.d
:CONFIG_COMMIT: 4cbdb3ce735ae296387069ef7ff309f0cfa812e8
:VIDEO_SCR_DIR: [[./src/inside-emacs-03/]]
:END:
** Built-in commands
*** global-map

- ~scroll-other-window~ (~M-<next>~): Scroll next window upward.
- ~scroll-other-window-down~ (~M-<prior>~): Scroll next window downward.

** External commands

- ~drag-stuff-down~ (from [[https://github.com/rejeep/drag-stuff.el][drag-stuff]]): Drag stuff down.
- ~mc/add-cursor-on-click~ (from [[https://github.com/magnars/multiple-cursors.el][multiple-cursors]]): Add a cursor where
  you click, or remove a fake cursor that is already there.
- ~mc/mark-next-like-this~ (from [[https://github.com/magnars/multiple-cursors.el][multiple-cursors]]): Find and mark the
  next part of the buffer matching the currently active region.
- ~sp-splice-sexp~ (from [[https://github.com/Fuco1/smartparens][smartparens]]): Unwrap the current list.
- ~sp-backward-kill-sexp~ (from [[https://github.com/Fuco1/smartparens][smartparens]]): Kill the balanced
  expression preceding point.
- ~yas-expand~ (from [[https://github.com/joaotavora/yasnippet][yasnippet]]): Expand a snippet before point.

** Customized commands
*** ta-mark-sexp-at-point

~ta-mark-sexp-at-point~: Mark the ~sexp~ at point.

#+BEGIN_SRC emacs-lisp
(require 'smartparens)

(defun ta--point-at-beginnig-sp-sexp-p ()
  "Return non-nil if `point' is at the beginning of a sp-sexp

and :op non empty. See `sp-get-thing'."
  (let ((ok (sp-get-thing)))
    (when ok
      (when (and (eq (point) (sp-get ok :beg))
                 (not (string-empty-p (sp-get ok :op))))
        (point)))))

(defun ta--mark-sexp-at-point ()
  "Mark the `sexp' at point."
  (let ((sexp-beg (beginning-of-thing 'sexp))
        (sexp-end (end-of-thing 'sexp)))
    (goto-char sexp-end)
    (set-mark sexp-end)
    (goto-char sexp-beg)))

(defun ta-mark-sexp-at-point ()
  "Mark the `sexp' at point. See `sexp-at-point' and `sp-mark-sexp'
(smartparens packages)."
  (interactive)
  (if (or (ta--point-at-beginnig-sp-sexp-p)
          (eq (following-char) ?<))
      (sp-mark-sexp)
    (if (eq (preceding-char) ?\")
        (progn
          (sp-backward-sexp)
          (sp-mark-sexp))
      (if (and (memq (following-char) '(32 ?\) ?\] ?\} ?>))
               (looking-back "[[:alnum:]]" 1))
          (backward-char 1))
      (ta--mark-sexp-at-point))))
#+END_SRC

*** ta-aw-other-window-scroll-buffer

~ta-aw-other-window-scroll-buffer~: Use ~ace-window~ to set
~other-window-scroll-buffer~ variable.

#+BEGIN_SRC emacs-lisp
(require 'ace-window)

(defun ta-aw-other-window-scroll-buffer ()
  "Use `ace-window' to set `other-window-scroll-buffer'."
  (interactive)
  (let ((initial-window (selected-window)))
    (save-excursion
      (call-interactively 'ace-window)
      (setq other-window-scroll-buffer (current-buffer)))
    (select-window initial-window)))

(defun ta-aw-reset-other-window-scroll-buffer ()
  "Reset `other-window-scroll-buffer' to nil when not a displayed buffer.

Use this function to advice `scroll-other-window' and `scroll-other-window-down'
before. This prevent to popup the buffer `other-window-scroll-buffer' if it
was not being displayed."
  (when (and other-window-scroll-buffer
             (not (get-buffer-window other-window-scroll-buffer)))
    (setq other-window-scroll-buffer nil)))

(defadvice scroll-other-window
    (before ta-aw-reset-other-window-scroll-buffer-advice activate)
  "Reset `other-window-scroll-buffer' to nil when not a displayed buffer.

This prevent to popup the buffer `other-window-scroll-buffer' if it
was not being displayed.

See `ta-aw-other-window-scroll-buffer'."
  (ta-aw-reset-other-window-scroll-buffer))

(defadvice scroll-other-window-down
    (before ta-aw-reset-other-window-scroll-buffer-advice activate)
  "Reset `other-window-scroll-buffer' to nil when not a displayed buffer.

This prevent to popup the buffer `other-window-scroll-buffer' if it
was not being displayed.

See `ta-aw-other-window-scroll-buffer'."
  (ta-aw-reset-other-window-scroll-buffer))
#+END_SRC

* [2020-08-07 Fri] winner-undo, transpose-frame, dired, kmacro, universal-argument | Inside Emacs #2
:PROPERTIES:
:YOUTUBE_TITLE: winner-undo, transpose-frame, dired, kmacro, universal-argument | Inside Emacs #2
:YOUTUBE_LINK: https://youtu.be/Tc4-sLf8HBc
:YOUTUBE_UPLOAD_DATE: [2020-08-07 Fri]
:CONFIG_REPO:   https://github.com/tonyaldon/emacs.d
:CONFIG_COMMIT: f760601bfc92bac7570f74396dbe1e4910af86af
:VIDEO_SCR_DIR: [[./src/inside-emacs-02/]]
:END:
** Built-in commands
*** without default key binding

- ~replace-string~: Interactively, replace occurrences of a string
  read in the minibuffer by another string read in the minibuffer.

*** global-map

- ~forward-paragraph~ (~C-<down>~): Move forward to end of paragraph.
- ~isearch-backward~ (~C-r~): Do incremental search backward.
- ~isearch-forward~ (~C-s~): Do incremental search forward.
- ~kmacro-bind-to-key~ (~C-x C-k b~): When not defining or executing a
  macro, offer to bind last macro to a key.
- ~kmacro-end-macro~ (~C-x )~): Finish defining a keyboard macro.
- ~kmacro-start-macro~ (~C-x (~): Record subsequent keyboard input,
  defining a keyboard macro.
- ~set-mark-command~ (~C-@~): Set the mark where point is, and activate
  it; or jump to the mark.
- ~universal-argument~ (~C-u~): Begin a numeric argument for the following
  command.
- ~winner-undo~ (~C-c <left>~): Switch back to an earlier window
  configuration saved by Winner mode.

*** dired-mode-map

- ~dired-do-find-marked-files~ (~F~): Find all marked files displaying all
  of them simultaneously.
- ~dired-mark~ (~m~): Mark the file at point in the Dired buffer.
- ~dired-unmark-all-marks~ (~U~): Remove all marks from all files in the
  Dired buffer.

** External commands

- ~avy-goto-word-or-subword-1~ (from [[https://github.com/abo-abo/avy][avy]]): Jump to the currently visible
  char (read in the minibuffer) at a subword or word start.
- ~dired-narrow~ (from [[https://melpa.org/#/dired-narrow][dired-narrow]]): Narrow a dired buffer to the files
  matching a string.
- ~er/expand-region~ (from [[https://github.com/magnars/expand-region.el][expand-region]]):
- ~mc/insert-numbers~ (from [[https://github.com/magnars/multiple-cursors.el][multiple-cursors]]): Insert increasing numbers
  for each cursor, starting at ~mc/insert-numbers-default~ or universal
  argument.
- ~mc/mark-next-like-this~ (from [[https://github.com/magnars/multiple-cursors.el][multiple-cursors]]): Find and mark the
  next part of the buffer matching the currently active region.
- ~transpose-frame~ (from [[https://melpa.org/#/transpose-frame][transpose-frame]]): Transpose windows
  arrangement at the current frame.
- ~yas-expand~ (from [[https://github.com/joaotavora/yasnippet][yasnippet]]): Expand a snippet before point. If no
  snippet

** Customized commands
*** ta-mark-inside-quotes-or-pairs

~ta-mark-inside-quotes-or-pairs~: Mark inside quotes or inside pairs
if called with universal argument.

#+BEGIN_SRC emacs-lisp
(require 'expand-region)
(require 'smartparens)

(defun ta-point-in-string-p (pt)
  "Returns t if PT is in a string"
  (eq 'string (syntax-ppss-context (syntax-ppss pt))))

(defun ta-goto-begining-of-string (pt)
  "Go to begining of the string if PT is inside a string.
Return nil if PT isn't inside a string. See the function `ta-point-in-string-p'"
  (if (ta-point-in-string-p pt)
      (goto-char (nth 8 (syntax-ppss pt)))
    nil))

(defun ta-mark-inside-pairs ()
  "An other way to do `er/mark-inside-pairs' but work for sgml-tag too."
  (interactive)
  (ta-goto-begining-of-string (point))
  (sp-backward-up-sexp)
  (sp-mark-sexp)
  (sp-down-sexp)
  (exchange-point-and-mark)
  (sp-backward-down-sexp)
  (exchange-point-and-mark))

(defun ta-mark-inside-quotes-or-pairs (&optional arg)
  "Mark inside quotes or inside pairs if call with universal argument.

When ARG is 4, mark inside pairs calling `ta-mark-inside-pairs'."
  (interactive "p")
  (if (equal arg 4)
      (call-interactively 'ta-mark-inside-pairs)
    (call-interactively 'er/mark-inside-quotes)))
#+END_SRC

*** ta-toggle-write-mode

~ta-toggle-write-mode~: Toggle to the Writable variant of the current
mode.

#+BEGIN_SRC emacs-lisp
(defun ta-toggle-write-mode ()
  "Toggle to the Writable variant of the current mode.

Call command `dired-toggle-read-only' if `major-mode' is equal
`dired-mode' and call command `wgrep-change-to-wgrep-mode' if
`major-mode' is equal to `grep-mode'."
  (interactive)
  (cond ((string-equal major-mode "dired-mode")
         (call-interactively 'dired-toggle-read-only))
        ((memq major-mode '(grep-mode ivy-occur-grep-mode))
         (call-interactively 'wgrep-change-to-wgrep-mode))
        (t (message "Must be in `dired-mode' or `grep-mode' mode."))))
#+END_SRC

*** ta-w-finish-edit

~ta-w-finish-edit~: Abort changes and return to the appropiate mode.

#+BEGIN_SRC emacs-lisp
(defun ta-w-finish-edit ()
  "Abort changes and return to the appropiate mode.

Call command `wdired-finish-edit' if `major-mode' is
`wdired-mode' and call command `wgrep-finish-edit' if
`major-mode' is `grep-mode'."
  (interactive)
  (cond ((string-equal major-mode "wdired-mode")
         (call-interactively 'wdired-finish-edit))
        ((memq major-mode '(grep-mode ivy-occur-grep-mode))
         (call-interactively 'wgrep-finish-edit))
        (t (message "Must be in `wdired-mode' or `grep-mode'."))))
#+END_SRC

* [2020-07-30 Thu] iedit-mode, multiple-cursors, iy-go-to-char, replace-string | Inside Emacs #1
:PROPERTIES:
:YOUTUBE_TITLE: iedit-mode, multiple-cursors, iy-go-to-char, replace-string | Inside Emacs #1
:YOUTUBE_LINK: https://youtu.be/F1IXixEhQwk
:YOUTUBE_UPLOAD_DATE: [2020-07-30 Thu]
:CONFIG_REPO:   https://github.com/tonyaldon/emacs.d
:CONFIG_COMMIT: f760601bfc92bac7570f74396dbe1e4910af86af
:VIDEO_SCR_DIR: [[./src/inside-emacs-01/]]
:END:
** Built-in commands
*** without default key binding

- ~replace-string~: Interactively, replace occurrences of a string read
  in the minibuffer by another string read in the minibuffer.

*** global-map

- ~scroll-left~ (~C-x <~): Scroll selected window display ARG columns
  left.
- ~scroll-right~ (~C-x >~): Scroll selected window display ARG columns
  right.
- ~yank-rectangle~ (~C-x r y~): Yank the last killed rectangle with upper
  left corner at point.

** External commands

- ~avy-goto-word-or-subword-1~ (from [[https://github.com/abo-abo/avy][avy]]): Jump to the currently visible
  char (read in the minibuffer) at a subword or word start.
- ~company-complete-selection~ (from [[https://github.com/company-mode/company-mode][company]]): Insert the selected
  candidate.
- ~er/expand-region~ (from [[https://github.com/magnars/expand-region.el][expand-region]]): Increase selected region by
  semantic units.
- ~iedit-mode~ (from [[https://github.com/victorhge/iedit][iedit]]): Toggle Iedit mode.  When Iedit mode is
  turned on, all the occurrences of the current region in the buffer
  (possibly narrowed) or a region are highlighted.  If one occurrence
  is modified, the change are propagated to all other occurrences
  simultaneously.
- ~iy-go-to-char~ (from [[https://github.com/doitian/iy-go-to-char][iy-go-to-char]]):  Move forward to next char read
  in the minibuffer.
- ~iy-go-to-char-kill-region~ (from [[https://github.com/doitian/iy-go-to-char][iy-go-to-char]]): Kill region between
  jump start position and current position.
- ~iy-go-to-char-kill-ring-save~ (from [[https://github.com/doitian/iy-go-to-char][iy-go-to-char]]): Save region
  between jump start position and current position.
- ~mc/insert-numbers~ (from [[https://github.com/magnars/multiple-cursors.el][multiple-cursors]]): Insert increasing numbers
  for each cursor, starting at ~mc/insert-numbers-default~ or universal
  argument.
- ~mc/mark-next-like-this~ (from [[https://github.com/magnars/multiple-cursors.el][multiple-cursors]]): Find and mark the
  next part of the buffer matching the currently active region.
- ~mc/mark-next-like-this-word~ (from [[https://github.com/magnars/multiple-cursors.el][multiple-cursors]]): Find and mark
  the next part of the buffer matching the currently active region.

** Customized commands
*** cleanup-buffer

~cleanup-buffer~: Convert all tabs into spaces, delete trailing spaces
and indent buffer.

#+BEGIN_SRC emacs-lisp
(defun cleanup-buffer ()
  "Convert all tabs into spaces, delete trailing spaces and indent buffer."
  (interactive)
  (untabify (point-min) (point-max))
  (delete-trailing-whitespace)
  (indent-region (point-min) (point-max)))
#+END_SRC

*** ta-avy-goto-end-of-line

~ta-avy-goto-end-of-line~: Jump to the visible end of line.

#+BEGIN_SRC emacs-lisp
(require 'avy)

(defun ta-avy-goto-end-of-line ()
  "Jump to the visible end of line.
Call `avy-goto-char' with \"\n\" as argument."
  (interactive)
  (avy-goto-char ?\n))
#+END_SRC

*** ta-mark-sexp-at-point

~ta-mark-sexp-at-point~: Mark the ~sexp~ at point.

#+BEGIN_SRC emacs-lisp
(require 'smartparens)

(defun ta--point-at-beginnig-sp-sexp-p ()
  "Return non-nil if `point' is at the beginning of a sp-sexp

and :op non empty. See `sp-get-thing'."
  (let ((ok (sp-get-thing)))
    (when ok
      (when (and (eq (point) (sp-get ok :beg))
                 (not (string-empty-p (sp-get ok :op))))
        (point)))))

(defun ta--mark-sexp-at-point ()
  "Mark the `sexp' at point."
  (let ((sexp-beg (beginning-of-thing 'sexp))
        (sexp-end (end-of-thing 'sexp)))
    (goto-char sexp-end)
    (set-mark sexp-end)
    (goto-char sexp-beg)))

(defun ta-mark-sexp-at-point ()
  "Mark the `sexp' at point. See `sexp-at-point' and `sp-mark-sexp'."
  (interactive)
  (if (or (ta--point-at-beginnig-sp-sexp-p)
          (eq (following-char) ?<))
      (sp-mark-sexp)
    (if (eq (preceding-char) ?\")
        (progn
          (sp-backward-sexp)
          (sp-mark-sexp))
      (if (and (memq (following-char) '(32 ?\) ?\] ?\} ?>))
               (looking-back "[[:alnum:]]" 1))
          (backward-char 1))
      (ta--mark-sexp-at-point))))
#+END_SRC

*** ta-toggle-narrow

~ta-toggle-narrow~: Toggle between ~widen~ and ~org-narrow-to-subtree~.

#+BEGIN_SRC emacs-lisp
(defun ta-toggle-narrow ()
  "Toggle between `widen' and `org-narrow-to-subtree'."
  (interactive)
  (if (buffer-narrowed-p) (widen)
    (org-narrow-to-subtree)))
#+END_SRC

~ta-yank-line-below~:  Copy current line and past it below.

#+BEGIN_SRC emacs-lisp
(defun ta-yank-line-below ()
  "Copy current line and past it below."
  (interactive)
  (let ((init-point (point))
        (line (buffer-substring-no-properties (point-at-bol) (point-at-eol))))
    (save-excursion
      (next-line)
      (beginning-of-line)
      (insert (concat line "\n")))))
#+END_SRC
